<!DOCTYPE html>
<html lang="ja">
<head>
  <base href="/karaokeenglish/">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ëã±Ë™û„Ç´„É©„Ç™„Ç± - English Karaoke</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* ‚îÄ‚îÄ Neutral Glass Theme ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    :root{
      --bg: linear-gradient(140deg, #f7f7f8 0%, #ffffff 55%, #eceef2 100%);
      --bg-overlay: rgba(255, 255, 255, 0.55);
      --ink:#101216;
      --muted:#646872;
      --panel: rgba(255, 255, 255, 0.78);
      --panel-hover: rgba(255, 255, 255, 0.9);
      --border: rgba(255, 255, 255, 0.65);
      --surface-outline: rgba(16, 18, 22, 0.08);
      --active-bg: rgba(16, 18, 22, 0.08);
      --active-text: #101216;
      --past-ink:#8b8f98;
      --glass-shadow: 0 24px 48px 0 rgba(16, 18, 22, 0.1);
      --glass-shadow-hover: 0 32px 68px 0 rgba(16, 18, 22, 0.18);
      --input-bg: rgba(255, 255, 255, 0.72);
      --button-bg: rgba(255, 255, 255, 0.68);
      --button-hover: rgba(255, 255, 255, 0.88);
      --white: #ffffff;
      --toggle-knob: rgba(16, 18, 22, 0.82);
      --accent-600: rgba(16, 18, 22, 0.75);
      --accent-500: rgba(16, 18, 22, 0.62);
      --accent-300: rgba(16, 18, 22, 0.35);
      --accent-100: rgba(16, 18, 22, 0.12);
      --accent-shadow: rgba(16, 18, 22, 0.14);
      --frost-line: rgba(255, 255, 255, 0.65);
      --frost-line-strong: rgba(255, 255, 255, 0.9);
      --match-bg: rgba(56, 176, 96, 0.16);
      --match-text: #1d5c45;
      --miss-bg: rgba(239, 71, 111, 0.12);
      --miss-text: #a53a54;
      --pending-text: rgba(16, 18, 22, 0.55);
      --drag-shadow: 0 18px 40px rgba(16, 18, 22, 0.18);
      --control-radius: 16px;
      --pill-radius: 999px;
    }
    
    [data-theme="dark"] {
      --bg: linear-gradient(160deg, #040404 0%, #0a0a0a 55%, #050505 100%);
      --bg-overlay: rgba(0, 0, 0, 0.65);
      --ink: #f5f5f5;
      --muted: #9ea2ac;
      --panel: rgba(12, 12, 12, 0.68);
      --panel-hover: rgba(12, 12, 12, 0.82);
      --border: rgba(255, 255, 255, 0.08);
      --surface-outline: rgba(0, 0, 0, 0.6);
      --active-bg: rgba(245, 245, 245, 0.12);
      --active-text: #f5f5f5;
      --past-ink: #6d7078;
      --glass-shadow: 0 28px 64px 0 rgba(0, 0, 0, 0.72);
      --glass-shadow-hover: 0 36px 80px 0 rgba(0, 0, 0, 0.86);
      --input-bg: rgba(12, 12, 12, 0.72);
      --button-bg: rgba(255, 255, 255, 0.08);
      --button-hover: rgba(255, 255, 255, 0.16);
      --white: #ffffff;
      --toggle-knob: rgba(255, 255, 255, 0.88);
      --accent-600: rgba(245, 245, 245, 0.88);
      --accent-500: rgba(245, 245, 245, 0.68);
      --accent-300: rgba(245, 245, 245, 0.38);
      --accent-100: rgba(245, 245, 245, 0.12);
      --accent-shadow: rgba(0, 0, 0, 0.7);
      --frost-line: rgba(255, 255, 255, 0.12);
      --frost-line-strong: rgba(255, 255, 255, 0.28);
      --match-bg: rgba(56, 176, 96, 0.22);
      --match-text: rgba(209, 246, 225, 0.92);
      --miss-bg: rgba(239, 71, 111, 0.24);
      --miss-text: rgba(255, 189, 201, 0.9);
      --pending-text: rgba(245, 245, 245, 0.48);
      --drag-shadow: 0 20px 48px rgba(0, 0, 0, 0.68);
    }
    *{box-sizing:border-box}
    html,body{height:100%; min-height:100vh}
    body{
      margin:0; font-family: "Noto Serif JP", "Georgia", "Times New Roman", serif;
      color:var(--ink);
      background: var(--bg);
      background-attachment: fixed;
      position: relative;
      touch-action: pan-y;
      overflow-x: hidden;
      overscroll-behavior-x: none;
      transition: background 0.3s ease, color 0.3s ease;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-overlay);
      pointer-events: none;
      z-index: 0;
    }
    .wrapper{max-width:1100px; margin:24px auto 40px; padding:0 16px; position: relative; z-index: 1}
    header{display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:12px; margin-bottom:24px}
    header h1{font-size:24px; font-weight:600; margin:0; letter-spacing:.01em; text-shadow: 0 2px 10px rgba(0,0,0,0.08)}
    header .sub{color:var(--muted); font-size:13px; margin-top:4px}
    .theme-toggle{
      cursor: pointer;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.15) 0%, 
        rgba(255, 255, 255, 0.05) 100%);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 50px;
      padding: 8px 16px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: var(--ink);
      transition: all 0.3s cubic-bezier(.4,0,.2,1);
      box-shadow: 
        0 8px 32px 0 rgba(0, 0, 0, 0.1),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.4),
        inset 0 -1px 0 0 rgba(0, 0, 0, 0.05);
    }
    [data-theme="dark"] .theme-toggle{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.08) 0%, 
        rgba(255, 255, 255, 0.02) 100%);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 
        0 8px 32px 0 rgba(0, 0, 0, 0.4),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.15),
        inset 0 -1px 0 0 rgba(0, 0, 0, 0.2);
    }
    .theme-toggle:hover{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.2) 0%, 
        rgba(255, 255, 255, 0.08) 100%);
      transform: translateY(-2px) scale(1.02);
      box-shadow: 
        0 12px 40px 0 rgba(0, 0, 0, 0.15),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.5),
        inset 0 -1px 0 0 rgba(0, 0, 0, 0.08);
    }
    .theme-toggle:active{
      transform: translateY(0) scale(0.98);
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.15),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.3),
        inset 0 2px 8px 0 rgba(0, 0, 0, 0.08);
    }
    .theme-toggle-icon{
      font-size: 18px;
    }

    .layout{display:flex; flex-direction:column; gap:18px; align-items:stretch}

    .card{
      position:relative;
      background: var(--panel);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border:1px solid var(--surface-outline);
      border-radius:20px;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      box-shadow: var(--glass-shadow);
    }
    .card::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:inherit;
      background: 
        radial-gradient(ellipse 120% 80% at 20% 30%, rgba(255, 255, 255, 0.5) 0%, transparent 60%),
        radial-gradient(ellipse 100% 80% at 80% 70%, rgba(255, 255, 255, 0.3) 0%, transparent 50%),
        linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.05));
      border:1px solid var(--frost-line);
      mix-blend-mode:overlay;
      pointer-events:none;
      opacity:0.9;
      filter: blur(0.5px);
    }
    .card::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:inherit;
      box-shadow: 
        inset 0 1px 0 var(--frost-line-strong), 
        inset 0 -24px 48px rgba(16, 18, 22, 0.08),
        inset 4px 0 12px -6px rgba(255, 255, 255, 0.5),
        inset -4px 0 12px -6px rgba(255, 255, 255, 0.5);
      pointer-events:none;
      opacity:0.8;
    }
    [data-theme="dark"] .card::before{
      background: linear-gradient(150deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.02));
      border-color: var(--frost-line);
      opacity:1;
      mix-blend-mode: normal;
    }
    [data-theme="dark"] .card::after{
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), inset 0 -32px 60px rgba(0, 0, 0, 0.5);
    }
    .card > *{
      position:relative;
      z-index:1;
    }
    .card .head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:18px 20px;
      border-bottom:1px solid var(--surface-outline);
      background: rgba(255, 255, 255, 0.05);
    }
    .card .head h2{font-size:16px; margin:0; color:var(--ink); letter-spacing:.01em; font-weight: 600}
    .card .body{padding:20px; display:flex; flex-direction:column; gap:16px}
    .card--reader .body{gap:18px}

    textarea{
      width:100%;
      min-height:260px;
      max-height:520px;
      resize:vertical;
      border-radius:15px;
      border:1px solid var(--surface-outline);
      background: var(--input-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color:var(--ink);
      padding:14px 16px;
      line-height:1.7;
      outline:none;
      font-size:15px;
      white-space:pre-wrap;
      box-shadow: var(--glass-shadow);
      transition: all 0.3s ease;
    }
    textarea:focus {
      border-color: var(--frost-line);
      box-shadow: 0 28px 60px 0 var(--accent-shadow);
      transform: translateY(-2px);
    }

    .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .controls button{
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding:0 20px;
      appearance:none;
      border-radius:var(--control-radius);
      border:1px solid rgba(255, 255, 255, 0.25);
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.15) 0%, 
        rgba(255, 255, 255, 0.05) 100%);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      color:var(--ink);
      height:40px;
      box-shadow: 
        0 8px 32px 0 rgba(0, 0, 0, 0.1),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.4),
        inset 0 -1px 0 0 rgba(0, 0, 0, 0.05);
      transition:transform .3s cubic-bezier(.4,0,.2,1), box-shadow .3s ease, background .3s ease, filter .3s ease;
      font-weight: 500;
      font-size:14px;
      position: relative;
      overflow: hidden;
    }
    .controls button::before{
      content:'';
      position:absolute;
      inset:0;
      background: radial-gradient(circle at center, rgba(255,255,255,0.3) 0%, transparent 70%);
      opacity:0;
      transform:scale(0);
      transition:transform .5s ease, opacity .5s ease;
    }
    .controls button::after{
      content:'';
      position:absolute;
      inset:-2px;
      background: inherit;
      filter: blur(20px);
      opacity:0;
      z-index:-1;
      transition:opacity .3s ease;
    }
    [data-theme="dark"] .controls button{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.08) 0%, 
        rgba(255, 255, 255, 0.02) 100%);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 
        0 8px 32px 0 rgba(0, 0, 0, 0.4),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.15),
        inset 0 -1px 0 0 rgba(0, 0, 0, 0.2);
    }
    .controls button:hover{
      transform:translateY(-2px) scale(1.02);
      box-shadow:
        0 12px 40px 0 rgba(0, 0, 0, 0.15),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.5),
        inset 0 -1px 0 0 rgba(0, 0, 0, 0.08);
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.2) 0%, 
        rgba(255, 255, 255, 0.08) 100%);
      filter: brightness(1.05);
    }
    .controls button:hover::after{
      opacity:0.6;
    }
    .controls button:active{
      transform:translateY(0) scale(0.96); 
      box-shadow:
        0 4px 16px rgba(0, 0, 0, 0.15),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.3),
        inset 0 2px 8px 0 rgba(0, 0, 0, 0.08);
      filter: brightness(0.95);
    }
    .controls button:active::before{
      opacity:1;
      transform:scale(2);
      transition:transform .2s ease, opacity .2s ease;
    }
    .controls button:disabled{
      opacity:.55; 
      cursor:not-allowed; 
      transform:none; 
      box-shadow: 
        inset 0 0 0 1px var(--surface-outline),
        0 2px 8px rgba(0, 0, 0, 0.05);
    }
    .controls--options{
      display:flex; 
      flex-wrap:wrap; 
      gap:12px; 
      align-items:center; 
      justify-content:center;
      padding: 20px 24px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 18px;
      backdrop-filter: blur(60px) saturate(180%);
      -webkit-backdrop-filter: blur(60px) saturate(180%);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        inset 0 -1px 0 rgba(0, 0, 0, 0.03);
      position: relative;
      overflow: visible;
      isolation: isolate;
    }
    .controls--options::before {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: inherit;
      padding: 1px;
      background: linear-gradient(135deg,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.05) 25%,
        transparent 50%,
        transparent 75%,
        rgba(255, 255, 255, 0.12) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite: exclude;
      pointer-events: none;
      z-index: 1;
      filter: blur(0.5px);
    }
    .controls--options::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: 
        radial-gradient(ellipse 100% 80% at 0% 50%, rgba(255, 255, 255, 0.18) 0%, transparent 40%),
        radial-gradient(ellipse 100% 80% at 100% 50%, rgba(255, 255, 255, 0.18) 0%, transparent 40%),
        radial-gradient(ellipse 80% 100% at 50% 0%, rgba(255, 255, 255, 0.15) 0%, transparent 40%),
        radial-gradient(ellipse 80% 100% at 50% 100%, rgba(0, 0, 0, 0.08) 0%, transparent 40%);
      pointer-events: none;
      z-index: 2;
      mix-blend-mode: overlay;
      filter: blur(2px) url(#lensDistortion);
      opacity: 0.6;
    }
    [data-theme="dark"] .controls--options {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(60px) saturate(150%);
      -webkit-backdrop-filter: blur(60px) saturate(150%);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    }
    [data-theme="dark"] .controls--options::after {
      background: 
        radial-gradient(ellipse 100% 80% at 0% 50%, rgba(255, 255, 255, 0.25) 0%, transparent 40%),
        radial-gradient(ellipse 100% 80% at 100% 50%, rgba(255, 255, 255, 0.25) 0%, transparent 40%),
        radial-gradient(ellipse 80% 100% at 50% 0%, rgba(255, 255, 255, 0.2) 0%, transparent 40%),
        radial-gradient(ellipse 80% 100% at 50% 100%, rgba(0, 0, 0, 0.3) 0%, transparent 40%);
      opacity: 0.75;
    }
    .control{display:flex; align-items:center; gap:8px; font-size:13px; color:var(--ink); position:relative; z-index:3}
    .control-title{font-size:12px; font-weight:500; color:var(--muted); white-space:nowrap}
    .control-body{
      display:flex;
      align-items:center;
      gap:10px;
      min-height:44px;
      padding:8px 12px;
      border-radius:var(--control-radius);
      border:none;
      background: transparent;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      box-shadow: none;
      transition:transform .25s ease;
    }
    .control-body:focus-within{
      transform:translateY(-2px);
    }
    .control-body--lang{
      padding:8px 12px;
      border-radius:var(--control-radius);
      border:none;
      background: transparent;
      box-shadow: none;
      transition:transform .25s ease;
      overflow:hidden;
      min-height:0;
    }
    .control-body--lang:focus-within{
      box-shadow:0 18px 38px 0 var(--accent-shadow);
      transform:translateY(-2px);
      border-color: var(--frost-line);
    }
    .control--lang{flex:1 1 240px;}
    .control--lang .control-title{letter-spacing:.12em;}
    .lang-toggle{
      position:relative;
      display:flex;
      gap:4px;
      padding:4px;
      border-radius:var(--pill-radius);
      background: rgba(255, 255, 255, 0.04);
      border:1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.06),
        inset 0 1px 1px rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(30px) saturate(180%);
      -webkit-backdrop-filter: blur(30px) saturate(180%);
      width:100%;
      align-items:stretch;
      isolation:isolate;
      --lang-toggle-padding:4px;
      --slider-offset:0px;
      --slider-width:0px;
      touch-action: pan-x;
      user-select:none;
      cursor:pointer;
    }
    [data-theme="dark"] .lang-toggle{
      background: rgba(255, 255, 255, 0.02);
      border-color: rgba(255, 255, 255, 0.06);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.25),
        inset 0 1px 1px rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(30px) saturate(150%);
      -webkit-backdrop-filter: blur(30px) saturate(150%);
    }
    .lang-toggle input{
      position:absolute;
      opacity:0;
      pointer-events:none;
    }
    .lang-toggle__option{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:9px 8px;
      border-radius:var(--pill-radius);
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:500;
      cursor:pointer;
      transition:color .25s ease, transform .25s cubic-bezier(.25,.8,.25,1);
      overflow:visible;
      flex:1 1 0;
      min-width:0;
      z-index:1;
      white-space:nowrap;
    }
    .lang-toggle__option:active{
      transform: scale(0.97);
    }
    .lang-toggle__option::after{
      content:'';
      position:absolute;
      inset:-2px;
      border-radius:inherit;
      border:2px solid transparent;
      transition:border-color .25s ease;
      pointer-events:none;
    }
    .lang-toggle input:checked + .lang-toggle__option{
      color:var(--active-text);
    }
    .lang-toggle input:focus-visible + .lang-toggle__option::after{
      border-color:rgba(16, 18, 22, 0.3);
    }
    [data-theme="dark"] .lang-toggle input:focus-visible + .lang-toggle__option::after{
      border-color:rgba(255, 255, 255, 0.32);
    }
    .lang-toggle__slider{
      position:absolute;
      top:var(--lang-toggle-padding, 4px);
      left:calc(var(--lang-toggle-padding, 4px) + var(--slider-offset, 0px));
      width:var(--slider-width, 0px);
      height:calc(100% - (var(--lang-toggle-padding, 4px) * 2));
      border-radius:var(--pill-radius);
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.5) 0%, 
        rgba(255, 255, 255, 0.35) 100%);
      border: 1px solid rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      box-shadow:
        0 8px 24px rgba(16, 18, 22, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        inset 0 -1px 0 rgba(0, 0, 0, 0.08);
      transition:left .35s cubic-bezier(.4,0,.2,1), width .35s cubic-bezier(.4,0,.2,1), box-shadow .35s cubic-bezier(.4,0,.2,1), transform .35s cubic-bezier(.4,0,.2,1);
      pointer-events:none;
      z-index:0;
      transform-origin: center center;
      will-change: transform;
    }
    [data-theme="dark"] .lang-toggle__slider{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.12) 0%, 
        rgba(255, 255, 255, 0.06) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px) saturate(150%);
      -webkit-backdrop-filter: blur(20px) saturate(150%);
      box-shadow:
        0 8px 28px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.12),
        inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    }
    .lang-toggle--dragging{
      box-shadow: var(--drag-shadow);
    }
    .lang-toggle--dragging .lang-toggle__slider{
      transition:left .12s cubic-bezier(.22,.61,.36,1), width .12s cubic-bezier(.22,.61,.36,1), box-shadow .2s ease, transform .15s cubic-bezier(.22,.61,.36,1);
      transform: scaleX(1.15) scaleY(0.92);
    }
    .lang-toggle__option.is-hovered{
      color:var(--active-text);
    }
    .lang-toggle--dragging .lang-toggle__option.is-hovered{
      transform:translateY(-1px) scale(1.02);
    }
    .control-body--toggle{justify-content:space-between; gap:16px}
    .control-body--toggle .toggle{width:100%; display:inline-flex; align-items:center; gap:12px; position:relative; cursor:pointer}
    .toggle input{position:absolute; opacity:0; width:0; height:0}
    .toggle-slider{
      width:50px;
      height:28px;
      border-radius:var(--pill-radius);
      background: var(--button-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      position:relative;
      transition:background-color .3s cubic-bezier(.4,0,.2,1), box-shadow .3s ease;
      border: 1px solid var(--surface-outline);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.08);
    }
    .toggle-slider::after{
      content:'';
      position:absolute;
      left:3px;
      top:3px;
      width:22px;
      height:22px;
      border-radius:50%;
      background:var(--toggle-knob);
      transition:transform .35s cubic-bezier(.4,0,.2,1), background-color .25s ease, box-shadow .25s ease;
      box-shadow: 0 3px 12px rgba(0,0,0,0.25), 0 1px 3px rgba(0,0,0,0.15);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
  .toggle input:checked + .toggle-slider{
    background:var(--active-bg);
    box-shadow: 0 6px 20px var(--accent-shadow), inset 0 2px 4px rgba(0,0,0,0.1);
  }
  .toggle input:checked + .toggle-slider::after{
    transform:translateX(22px);
    background:var(--white);
    box-shadow:0 4px 16px var(--accent-shadow), 0 2px 6px rgba(0,0,0,0.2);
  }
  .toggle:active .toggle-slider::after{
    transform:translateX(0px) scaleX(1.15);
  }
  .toggle input:checked + .toggle-slider:active::after{
    transform:translateX(22px) scaleX(1.15);
  }
  .toggle.toggle-dragging .toggle-slider::after{
    transition:transform .12s cubic-bezier(.22,.61,.36,1), background-color .25s ease, box-shadow .25s ease;
  }
  .toggle.toggle-dragging input:not(:checked) + .toggle-slider::after{
    transform:translateX(0px) scaleX(1.2) scaleY(0.9);
  }
  .toggle.toggle-dragging input:checked + .toggle-slider::after{
    transform:translateX(22px) scaleX(1.2) scaleY(0.9);
  }
  [data-theme="dark"] .toggle input:checked + .toggle-slider{
    background:rgba(245, 245, 245, 0.35);
  }
  [data-theme="dark"] .toggle input:checked + .toggle-slider::after{
    background:var(--toggle-knob);
  }
    .toggle-label{font-size:12px; color:var(--muted); font-weight:500; transition:color .2s ease}
  .toggle input:checked + .toggle-slider + .toggle-label{color:var(--active-text)}
    /* Mode toggle - same style as language toggle */
    .mode-toggle{
      position:relative;
      display:flex;
      gap:4px;
      padding:4px;
      border-radius:var(--pill-radius);
      background: rgba(255, 255, 255, 0.04);
      border:1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.06),
        inset 0 1px 1px rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(30px) saturate(180%);
      -webkit-backdrop-filter: blur(30px) saturate(180%);
      width:100%;
      align-items:stretch;
      isolation:isolate;
      --mode-toggle-padding:4px;
      --mode-slider-offset:0px;
      --mode-slider-width:0px;
      touch-action: pan-x;
      user-select:none;
      cursor:pointer;
    }
    [data-theme="dark"] .mode-toggle{
      background: rgba(255, 255, 255, 0.02);
      border-color: rgba(255, 255, 255, 0.06);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.25),
        inset 0 1px 1px rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(30px) saturate(150%);
      -webkit-backdrop-filter: blur(30px) saturate(150%);
    }
    .mode-toggle input{
      position:absolute;
      opacity:0;
      pointer-events:none;
    }
    .mode-toggle__option{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px 16px;
      border-radius:var(--pill-radius);
      font-size:12px;
      letter-spacing:.05em;
      color:var(--muted);
      font-weight:500;
      cursor:pointer;
      transition:color .25s ease, transform .25s cubic-bezier(.25,.8,.25,1);
      overflow:visible;
      flex:1 1 0;
      min-width:0;
      z-index:1;
      white-space:nowrap;
    }
    .mode-toggle__option:active{
      transform: scale(0.97);
    }
    .mode-toggle__option::after{
      content:'';
      position:absolute;
      inset:-2px;
      border-radius:inherit;
      border:2px solid transparent;
      transition:border-color .25s ease;
      pointer-events:none;
    }
    .mode-toggle input:checked + .mode-toggle__option{
      color:var(--active-text);
    }
    .mode-toggle input:focus-visible + .mode-toggle__option::after{
      border-color:rgba(16, 18, 22, 0.3);
    }
    [data-theme="dark"] .mode-toggle input:focus-visible + .mode-toggle__option::after{
      border-color:rgba(255, 255, 255, 0.32);
    }
    .mode-toggle__slider{
      position:absolute;
      top:var(--mode-toggle-padding, 4px);
      left:calc(var(--mode-toggle-padding, 4px) + var(--mode-slider-offset, 0px));
      width:var(--mode-slider-width, 0px);
      height:calc(100% - (var(--mode-toggle-padding, 4px) * 2));
      border-radius:var(--pill-radius);
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.5) 0%, 
        rgba(255, 255, 255, 0.35) 100%);
      border: 1px solid rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      box-shadow:
        0 8px 24px rgba(16, 18, 22, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        inset 0 -1px 0 rgba(0, 0, 0, 0.08);
      transition:left .35s cubic-bezier(.4,0,.2,1), width .35s cubic-bezier(.4,0,.2,1), box-shadow .35s cubic-bezier(.4,0,.2,1), transform .35s cubic-bezier(.4,0,.2,1);
      pointer-events:none;
      z-index:0;
      transform-origin: center center;
      will-change: transform;
    }
    [data-theme="dark"] .mode-toggle__slider{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.12) 0%, 
        rgba(255, 255, 255, 0.06) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px) saturate(150%);
      -webkit-backdrop-filter: blur(20px) saturate(150%);
      box-shadow:
        0 8px 28px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.12),
        inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    }
    .mode-toggle--dragging{
      box-shadow: var(--drag-shadow);
    }
    .mode-toggle--dragging .mode-toggle__slider{
      transition:left .12s cubic-bezier(.22,.61,.36,1), width .12s cubic-bezier(.22,.61,.36,1), box-shadow .2s ease, transform .15s cubic-bezier(.22,.61,.36,1);
      transform: scaleX(1.15) scaleY(0.92);
    }
    .mode-toggle__option.is-hovered{
      color:var(--ink);
    }
    .mode-toggle--dragging .mode-toggle__option.is-hovered{
      color:var(--ink);
    }
    
    /* Scroll toggle - same style as language and mode */
    .scroll-toggle{
      position:relative;
      display:flex;
      gap:4px;
      padding:4px;
      border-radius:var(--pill-radius);
      background: rgba(255, 255, 255, 0.04);
      border:1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.06),
        inset 0 1px 1px rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(30px) saturate(180%);
      -webkit-backdrop-filter: blur(30px) saturate(180%);
      width:100%;
      align-items:stretch;
      isolation:isolate;
      --scroll-toggle-padding:4px;
      --scroll-slider-offset:0px;
      --scroll-slider-width:0px;
      touch-action: pan-x;
      user-select:none;
      cursor:pointer;
    }
    [data-theme="dark"] .scroll-toggle{
      background: rgba(255, 255, 255, 0.02);
      border-color: rgba(255, 255, 255, 0.06);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.25),
        inset 0 1px 1px rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(30px) saturate(150%);
      -webkit-backdrop-filter: blur(30px) saturate(150%);
    }
    .scroll-toggle input{
      position:absolute;
      opacity:0;
      pointer-events:none;
    }
    .scroll-toggle__option{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px 16px;
      border-radius:var(--pill-radius);
      font-size:12px;
      letter-spacing:.05em;
      color:var(--muted);
      font-weight:500;
      cursor:pointer;
      transition:color .25s ease, transform .25s cubic-bezier(.25,.8,.25,1);
      overflow:visible;
      flex:1 1 0;
      min-width:0;
      z-index:1;
      white-space:nowrap;
    }
    .scroll-toggle__option:active{
      transform: scale(0.97);
    }
    .scroll-toggle__option::after{
      content:'';
      position:absolute;
      inset:-2px;
      border-radius:inherit;
      border:2px solid transparent;
      transition:border-color .25s ease;
      pointer-events:none;
    }
    .scroll-toggle input:checked + .scroll-toggle__option{
      color:var(--active-text);
    }
    .scroll-toggle input:focus-visible + .scroll-toggle__option::after{
      border-color:rgba(16, 18, 22, 0.3);
    }
    [data-theme="dark"] .scroll-toggle input:focus-visible + .scroll-toggle__option::after{
      border-color:rgba(255, 255, 255, 0.32);
    }
    .scroll-toggle__slider{
      position:absolute;
      top:var(--scroll-toggle-padding, 4px);
      left:calc(var(--scroll-toggle-padding, 4px) + var(--scroll-slider-offset, 0px));
      width:var(--scroll-slider-width, 0px);
      height:calc(100% - (var(--scroll-toggle-padding, 4px) * 2));
      border-radius:var(--pill-radius);
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.5) 0%, 
        rgba(255, 255, 255, 0.35) 100%);
      border: 1px solid rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      box-shadow:
        0 8px 24px rgba(16, 18, 22, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        inset 0 -1px 0 rgba(0, 0, 0, 0.08);
      transition:left .35s cubic-bezier(.4,0,.2,1), width .35s cubic-bezier(.4,0,.2,1), box-shadow .35s cubic-bezier(.4,0,.2,1), transform .35s cubic-bezier(.4,0,.2,1);
      pointer-events:none;
      z-index:0;
      transform-origin: center center;
      will-change: transform;
    }
    [data-theme="dark"] .scroll-toggle__slider{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.12) 0%, 
        rgba(255, 255, 255, 0.06) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px) saturate(150%);
      -webkit-backdrop-filter: blur(20px) saturate(150%);
      box-shadow:
        0 8px 28px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.12),
        inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    }
    .scroll-toggle--dragging{
      box-shadow: var(--drag-shadow);
    }
    .scroll-toggle--dragging .scroll-toggle__slider{
      transition:left .12s cubic-bezier(.22,.61,.36,1), width .12s cubic-bezier(.22,.61,.36,1), box-shadow .2s ease, transform .15s cubic-bezier(.22,.61,.36,1);
      transform: scaleX(1.15) scaleY(0.92);
    }
    .scroll-toggle__option.is-hovered{
      color:var(--ink);
    }
    
    .control-body--segment,
    .control-body--scroll{
      padding:0;
      min-height:auto;
    }

    .controls--mic{gap:12px; flex-wrap:wrap; justify-content:center}
    .controls--mic button{min-width:160px; justify-content:center}

    /* Ë™≠„Åø‰∏ä„ÅíË°®Á§∫ÔºàÈü≥Â£∞Ë™çË≠ò„Éè„Ç§„É©„Ç§„Éà„ÅÆ„ÅøÔºâ */
    .reader{
      flex:1;
      min-height:320px;
      line-height:1.7;
      font-size:16px;
      letter-spacing:.01em;
      white-space:pre-wrap;
      background: var(--input-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border:1px solid var(--surface-outline);
      border-radius:var(--control-radius);
      padding:18px;
      overflow:auto;
      box-shadow: var(--glass-shadow);
    }
    .word{
      position:relative;
      display:inline-flex;
      align-items:center;
      padding:4px 8px;
      border-radius:8px;
      cursor:pointer;
      color:var(--ink);
      -webkit-text-fill-color:currentColor;
      isolation:isolate;
      transition:color .2s ease;
      will-change:color;
    }
    .word::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:inherit;
      background:transparent;
      box-shadow:none;
      transition:background-color .2s ease, box-shadow .2s ease, transform .2s ease;
      z-index:-1;
    }
    .word:hover::before{
      background: var(--button-hover);
      box-shadow:0 4px 12px var(--accent-shadow);
      transform:translateY(-1px);
    }
    .word.word--pending{
      color:var(--pending-text);
    }
    .word.word--matched{
      color:var(--match-text);
      font-weight:600;
    }
    .word.word--matched::before{
      background:var(--match-bg);
      box-shadow:0 4px 14px rgba(16, 18, 22, 0.18);
    }
    .word.word--missed{
      color:var(--miss-text);
      font-weight:600;
      text-decoration: underline wavy currentColor;
      text-decoration-thickness: 2px;
      text-underline-offset: 6px;
    }
    .word.word--missed::before{
      background:var(--miss-bg);
      box-shadow:0 4px 14px rgba(16, 18, 22, 0.14);
    }
    .word.word--active{
      color:var(--active-text);
      font-weight:600;
    }
    .word.word--active::before{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.65) 0%, 
        rgba(255, 255, 255, 0.45) 100%);
      border: 1px solid rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      box-shadow:
        0 8px 32px rgba(16, 18, 22, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      transform:translateY(-1px);
    }
    .word.word--active.word--matched::before{
      background: linear-gradient(135deg, 
        rgba(76, 175, 80, 0.4) 0%, 
        rgba(56, 142, 60, 0.35) 100%);
      border: 1px solid rgba(76, 175, 80, 0.6);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      box-shadow:
        0 8px 32px rgba(76, 175, 80, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.5),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    }
    .word.word--active.word--missed::before{
      background: linear-gradient(135deg, 
        rgba(244, 67, 54, 0.4) 0%, 
        rgba(211, 47, 47, 0.35) 100%);
      border: 1px solid rgba(244, 67, 54, 0.6);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      box-shadow:
        0 8px 32px rgba(244, 67, 54, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.5),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    }
    [data-theme="dark"] .word.word--active::before{
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.18) 0%, 
        rgba(255, 255, 255, 0.12) 100%);
      border: 1px solid rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(24px) saturate(150%);
      -webkit-backdrop-filter: blur(24px) saturate(150%);
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
    }
    [data-theme="dark"] .word.word--active.word--matched::before{
      background: linear-gradient(135deg, 
        rgba(76, 175, 80, 0.3) 0%, 
        rgba(56, 142, 60, 0.25) 100%);
      border: 1px solid rgba(76, 175, 80, 0.45);
      backdrop-filter: blur(24px) saturate(150%);
      -webkit-backdrop-filter: blur(24px) saturate(150%);
      box-shadow:
        0 8px 32px rgba(76, 175, 80, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.25),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
    }
    [data-theme="dark"] .word.word--active.word--missed::before{
      background: linear-gradient(135deg, 
        rgba(244, 67, 54, 0.3) 0%, 
        rgba(211, 47, 47, 0.25) 100%);
      border: 1px solid rgba(244, 67, 54, 0.45);
      backdrop-filter: blur(24px) saturate(150%);
      -webkit-backdrop-filter: blur(24px) saturate(150%);
      box-shadow:
        0 8px 32px rgba(244, 67, 54, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.25),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
    }
    @supports (-webkit-touch-callout: none){
      .word::before,
      .word.word--active::before{
        transform:none !important;
      }
    }
    @media (prefers-reduced-motion: reduce){
      .word::before{
        transition:background-color .2s ease, box-shadow .2s ease;
      }
    }

    .session-status{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:16px;
      padding:12px 16px;
      border-radius:var(--control-radius);
      border:1px solid var(--surface-outline);
      background: var(--input-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      box-shadow: var(--glass-shadow);
    }
    .session-status__text{
      font-size:14px;
      color:var(--ink);
      font-weight:500;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:8px}
    .kbd{
      border:1px solid var(--surface-outline);
      padding:.1em .4em;
      border-radius:6px;
      background: var(--button-bg);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    footer{margin-top:18px; color:var(--muted); font-size:12px}
    a{color:inherit; text-decoration:underline}

    .card{transition:transform .25s ease, box-shadow .25s ease}
    .card:hover{
      transform:translateY(-6px);
      box-shadow:0 24px 72px 0 rgba(16, 18, 22, 0.16);
    }
    .reader{transition:box-shadow .25s ease, transform .25s ease}
    .reader:focus-within, .reader:hover{
      box-shadow:0 24px 48px 0 var(--accent-shadow);
      transform: translateY(-2px);
    }

    /* ‚îÄ‚îÄ Responsive Design for Mobile and Tablet ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    @media (max-width: 768px) {
      .wrapper { padding: 0 16px; margin: 20px auto 32px; }
      header { flex-direction: row; align-items: center; gap: 12px; margin-bottom: 20px; }
      header h1 { font-size: 20px; }
      header .sub { font-size: 12px; }
      
      .layout { gap: 16px; }
      .card { border-radius: 16px; }
      .card .head { flex-direction: column; align-items: stretch; padding: 16px; gap: 12px; }
      .card .head h2 { font-size: 16px; }
      .card .head .controls { flex-direction: column; width: 100%; align-items:stretch; }
      .card .head .controls button { width: 100%; justify-content: center; }
      .card .body { padding: 16px; gap: 16px; }
      
      textarea { min-height: 200px; font-size: 15px; padding: 14px; }
      
      /* Premium mobile layout: unified glass panel with lens distortion at edges */
      .controls--options { 
        flex-direction: column; 
        gap: 20px; 
        align-items: stretch;
        padding: 24px 20px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        backdrop-filter: blur(60px) saturate(180%);
        -webkit-backdrop-filter: blur(60px) saturate(180%);
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.12),
          inset 0 1px 0 rgba(255, 255, 255, 0.3),
          inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: visible;
        isolation: isolate;
      }
      
      /* Lens distortion effect at edges - Apple liquid glass style */
      .controls--options::before {
        content: '';
        position: absolute;
        inset: -1px;
        border-radius: inherit;
        padding: 1px;
        background: linear-gradient(135deg,
          rgba(255, 255, 255, 0.4) 0%,
          rgba(255, 255, 255, 0.1) 25%,
          transparent 50%,
          transparent 75%,
          rgba(255, 255, 255, 0.3) 100%);
        -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        mask-composite: exclude;
        pointer-events: none;
        z-index: 1;
        filter: blur(0.5px);
      }
      
      /* Edge highlights - simulate light refraction through curved glass */
      .controls--options::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: 
          radial-gradient(ellipse 100% 80% at 0% 50%, rgba(255, 255, 255, 0.4) 0%, transparent 40%),
          radial-gradient(ellipse 100% 80% at 100% 50%, rgba(255, 255, 255, 0.4) 0%, transparent 40%),
          radial-gradient(ellipse 80% 100% at 50% 0%, rgba(255, 255, 255, 0.35) 0%, transparent 40%),
          radial-gradient(ellipse 80% 100% at 50% 100%, rgba(0, 0, 0, 0.15) 0%, transparent 40%);
        pointer-events: none;
        z-index: 2;
        mix-blend-mode: overlay;
        filter: blur(2px) url(#lensDistortion);
        opacity: 0.85;
      }
      
      .control { 
        flex: 1 1 auto; 
        width: 100%; 
        min-width: 0; 
        display: flex; 
        flex-direction: row;
        align-items: center; 
        justify-content: flex-start;
        gap: 14px;
        padding: 0;
        position: relative;
        z-index: 3;
      }
      
      .control-title { 
        font-size: 13px;
        font-weight: 600;
        white-space: nowrap;
        text-align: left;
        color: var(--ink);
        letter-spacing: 0.02em;
        flex-shrink: 0;
        width: 112px;
        margin: 0;
        padding: 0;
      }
      
      .control-body { 
        min-height: 44px; 
        padding: 7px 10px;
        flex: 1 1 0;
        min-width: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      /* Language toggle: full width of control-body */
      .control--lang {
        flex: 1 1 auto;
      }
      .control-body--lang { 
        width: 100%;
        justify-content: stretch;
      }
      .lang-toggle {
        width: 100%;
      }
      
      /* Mode segment buttons: perfectly centered */
      .control-body--segment { 
        justify-content: center;
        width: 100%;
        padding: 6px 8px;
        gap: 8px;
      }
      .segment { 
        min-width: 0;
        flex: 1 1 0;
        max-width: none;
      }
      .segment span {
        width: 100%;
      }
      
      /* Auto-scroll toggle: centered in control-body */
      .control-body--toggle { 
        width: 100%;
        padding: 8px 12px;
        justify-content: center;
      }
      .control-body--toggle .toggle { 
        width: auto; 
        flex-shrink: 0;
      }
      .toggle-slider {
        width: 50px;
        height: 28px;
      }
      .toggle-slider::after {
        width: 22px;
        height: 22px;
      }

      .session-status { padding: 14px 16px; }
      .session-status__text { font-size: 13px; }

      /* Remove individual control borders - unified glass panel */
      .control-body--lang,
      .control-body--segment,
      .control-body--toggle {
        background: transparent;
        border: none;
        box-shadow: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: visible;
      }

      
      [data-theme="dark"] .controls--options {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(60px) saturate(150%);
        -webkit-backdrop-filter: blur(60px) saturate(150%);
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.15),
          inset 0 -1px 0 rgba(0, 0, 0, 0.2);
      }
      
      [data-theme="dark"] .controls--options::after {
        background: 
          radial-gradient(ellipse 100% 80% at 0% 50%, rgba(255, 255, 255, 0.25) 0%, transparent 40%),
          radial-gradient(ellipse 100% 80% at 100% 50%, rgba(255, 255, 255, 0.25) 0%, transparent 40%),
          radial-gradient(ellipse 80% 100% at 50% 0%, rgba(255, 255, 255, 0.2) 0%, transparent 40%),
          radial-gradient(ellipse 80% 100% at 50% 100%, rgba(0, 0, 0, 0.3) 0%, transparent 40%);
        opacity: 0.75;
      }
      
      [data-theme="dark"] .control-body--lang,
      [data-theme="dark"] .control-body--segment,
      [data-theme="dark"] .control-body--toggle {
        background: transparent;
        border: none;
        box-shadow: none;
      }
      
      .control-body--lang:active,
      .control-body--segment:active,
      .control-body--toggle:active {
        transform: scale(0.98);
      }

      .control-body--segment::before {
        box-shadow: 0 12px 28px var(--accent-shadow);
      }
      
      .controls--mic { flex-direction: column; gap: 12px; }
      .controls--mic button { width: 100%; min-width: 100%; }
      
      .reader { min-height: 280px; font-size: 16px; padding: 16px; line-height: 1.75; }
      .hint { font-size: 12px; }
      footer { font-size: 11px; margin-top: 16px; }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      .wrapper { max-width: 900px; padding: 0 24px; }
      header h1 { font-size: 22px; }
      .controls--options { gap: 12px; }
      .reader { font-size: 16px; }
    }

    @media (max-width: 480px) {
      .wrapper { padding: 0 12px; }
      header h1 { font-size: 18px; }
      .card .head { padding: 14px; }
      .card .body { padding: 14px; }
      .reader { min-height: 240px; font-size: 15px; padding: 14px; }
      .control-body { font-size: 13px; }
      
      /* Extra small screens: adjust for very tight space */
      .controls--options { gap: 16px; }
      .control { gap: 10px; }
      .control-title { 
        font-size: 11px;
        width: 88px;
      }
      
      /* Language toggle: smaller text to prevent overflow */
      .lang-toggle__option {
        padding: 8px 5px;
        font-size: 9px;
        letter-spacing: 0.05em;
      }
      
      /* Mode segments: compact on tiny screens, keep centered */
      .control-body--segment { 
        flex-direction: row; 
        flex-wrap: nowrap;
        gap: 5px; 
        justify-content: center;
        align-items: center;
        padding: 5px;
        width: 100%;
      }
      .segment { 
        flex: 1 1 0;
        min-width: 0;
        max-width: 75px;
      }
      .segment span { 
        padding: 6px 10px; 
        display: inline-block; 
        font-size: 11px;
        white-space: nowrap;
      }
      
      .session-status__text { font-size: 12px; }
    }
    @media (prefers-reduced-motion: reduce) {
      .lang-toggle__slider,
      .control-body--segment::before {
        transition: none;
      }
    }
  </style>
</head>
<body>
  <!-- SVG Filter for realistic lens distortion -->
  <svg style="position: absolute; width: 0; height: 0;" aria-hidden="true">
    <defs>
      <filter id="lensDistortion" x="-50%" y="-50%" width="200%" height="200%">
        <feTurbulence type="fractalNoise" baseFrequency="0.01 0.01" numOctaves="2" result="noise" seed="2" />
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="3" xChannelSelector="R" yChannelSelector="G" />
      </filter>
      <filter id="glassBlur">
        <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" />
      </filter>
    </defs>
  </svg>
  <div class="wrapper">
    <header>
      <div>
        <h1>üé§ Ëã±Ë™û„Ç´„É©„Ç™„Ç±</h1>
        <div class="sub">Èü≥Â£∞Ë™çË≠ò„ÅßËã±Ë™ûÂ≠¶Áøí</div>
      </div>
      <button class="theme-toggle" id="themeToggle">
        <span class="theme-toggle-icon" id="themeIcon">üåô</span>
        <span id="themeText">„ÉÄ„Éº„ÇØ„É¢„Éº„Éâ</span>
      </button>
    </header>

    <div class="layout">
      <section class="card card--input">
        <div class="head">
          <h2>„ÉÜ„Ç≠„Çπ„ÉàÔºà„Çπ„ÇØ„É™„Éó„Éà„ÇíË≤º„Çä‰ªò„ÅëÔºâ</h2>
          <div class="controls">
            <button id="loadSample">„Çµ„É≥„Éó„É´</button>
            <button id="resetHL">„Éè„Ç§„É©„Ç§„Éà„Çí„É™„Çª„ÉÉ„Éà</button>
          </div>
        </div>
        <div class="body">
          <textarea id="textInput" spellcheck="false" placeholder="„Åì„Åì„Å´Ëã±Êñá„Çπ„ÇØ„É™„Éó„Éà„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ"></textarea>
          <div class="hint">ÂçòË™ûÂçò‰Ωç„ÅßÂàÜÂâ≤„Åó„ÄÅÁô∫Ë©±„Å´Âøú„Åò„Å¶ <b>ÁèæÂú®„ÅÆÂçòË™û</b> „Å® <b>Ê≠£„Åó„ÅèË™≠„ÇÅ„ÅüÂçòË™ûÔºàÁ∑ëÔºâ</b>Ôºè<b>ËÅû„ÅçÂèñ„Çä„Å´„Åè„Åã„Å£„ÅüÂçòË™ûÔºàËµ§Ôºâ</b> „ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ‰ªªÊÑè„ÅÆÂçòË™û„Çí„Çø„ÉÉ„Éó„Åô„Çã„Å®„Åù„ÅÆ‰ΩçÁΩÆ„Åã„ÇâÂÜçÈñã„Åß„Åç„Åæ„Åô„ÄÇ</div>
        </div>
      </section>

      <section class="card card--reader">
        <div class="head">
          <h2>Èü≥Â£∞Ë™çË≠ò</h2>
          <div class="controls controls--options">
            <div class="control control--lang">
              <span class="control-title">Ë®ÄË™û:</span>
              <div class="control-body control-body--lang" role="presentation">
                <div class="lang-toggle" role="radiogroup" aria-label="Recognition language">
                  <span class="lang-toggle__slider" aria-hidden="true"></span>
                  <input type="radio" id="lang-en-us" name="recLang" value="en-US" checked>
                  <label class="lang-toggle__option" for="lang-en-us">EN-US</label>
                  <input type="radio" id="lang-en-gb" name="recLang" value="en-GB">
                  <label class="lang-toggle__option" for="lang-en-gb">EN-GB</label>
                  <input type="radio" id="lang-ja-jp" name="recLang" value="ja-JP">
                  <label class="lang-toggle__option" for="lang-ja-jp">JA-JP</label>
                  <input type="radio" id="lang-ru-ru" name="recLang" value="ru-RU">
                  <label class="lang-toggle__option" for="lang-ru-ru">RU-RU</label>
                  <input type="radio" id="lang-vi-vn" name="recLang" value="vi-VN">
                  <label class="lang-toggle__option" for="lang-vi-vn">VI-VN</label>
                </div>
              </div>
            </div>
            <div class="control">
              <span class="control-title">„É¢„Éº„Éâ:</span>
              <div class="control-body control-body--segment">
                <div class="mode-toggle" role="radiogroup" aria-label="Recognition mode">
                  <span class="mode-toggle__slider" aria-hidden="true"></span>
                  <input type="radio" id="mode-precise" name="recMode" value="precise" checked>
                  <label class="mode-toggle__option" for="mode-precise">Ê≠£Á¢∫</label>
                  <input type="radio" id="mode-speed" name="recMode" value="speed">
                  <label class="mode-toggle__option" for="mode-speed">È´òÈÄü</label>
                </div>
              </div>
            </div>
            <div class="control">
              <span class="control-title">„Çπ„ÇØ„É≠„Éº„É´:</span>
              <div class="control-body control-body--scroll">
                <div class="scroll-toggle" role="radiogroup" aria-label="Scroll mode">
                  <span class="scroll-toggle__slider" aria-hidden="true"></span>
                  <input type="radio" id="scroll-auto" name="scrollMode" value="auto" checked>
                  <label class="scroll-toggle__option" for="scroll-auto">Ëá™Âãï</label>
                  <input type="radio" id="scroll-manual" name="scrollMode" value="manual">
                  <label class="scroll-toggle__option" for="scroll-manual">ÊâãÂãï</label>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="body">
          <div class="session-status">
            <span class="session-status__text" id="recStatus">Ê∫ñÂÇôÂÆå‰∫Ü</span>
          </div>
          <div class="controls controls--mic">
            <button id="btnMicStart">üé§ ÈñãÂßã (<span class="kbd">S</span>)</button>
            <button id="btnMicStop" disabled>‚ñ† ÂÅúÊ≠¢</button>
          </div>
          <div id="reader" class="reader" aria-live="polite"></div>
          <div class="hint">ÂçòË™û„Çí„Çø„ÉÉ„Éó„Åó„Å¶‰ΩçÁΩÆ„ÇíÁßªÂãï | <span class="kbd">S</span>: ÈñãÂßã/ÂÅúÊ≠¢ | <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span>: ÂâçÂæåÁßªÂãï</div>
        </div>
      </section>
    </div>

    <footer>
      <div>ÂØæÂøú: Chrome / EdgeÔºàSpeechRecognitionÔºâ„ÄÇSafari ‰∏ÄÈÉ®Êú™ÂØæÂøú„ÄÇÂàùÂõû„ÅØ„Éû„Ç§„ÇØË®±ÂèØ„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ</div>
    </footer>
  </div>

  <script>
  // ====== Ë¶ÅÁ¥†ÂèÇÁÖß ======
  const textInput = document.getElementById('textInput');
  const reader = document.getElementById('reader');
  const loadSample = document.getElementById('loadSample');
  const resetHL = document.getElementById('resetHL');
  const recLangRadios = Array.from(document.querySelectorAll('input[name="recLang"]'));
  const langToggleEl = document.querySelector('.lang-toggle');
  const langSliderEl = langToggleEl ? langToggleEl.querySelector('.lang-toggle__slider') : null;
  const recStatus = document.getElementById('recStatus');
  const updateLangSlider = () => {
    if (!langToggleEl || !langSliderEl) return;
    const activeInput = langToggleEl.querySelector('input[type="radio"]:checked');
    if (!activeInput) return;
    const activeLabel = langToggleEl.querySelector(`label[for="${activeInput.id}"]`);
    if (!activeLabel) return;
    const langRect = langToggleEl.getBoundingClientRect();
    const labelRect = activeLabel.getBoundingClientRect();
    if (!labelRect.width) return;
    const styles = getComputedStyle(langToggleEl);
    const paddingLeft = parseFloat(styles.paddingLeft) || 0;
    const borderLeft = parseFloat(styles.borderLeftWidth) || 0;
    const offset = labelRect.left - langRect.left - borderLeft - paddingLeft;
    langToggleEl.style.setProperty('--slider-offset', `${offset}px`);
    langToggleEl.style.setProperty('--slider-width', `${labelRect.width}px`);
  };
  if (langToggleEl && langSliderEl) {
    const scheduleLangSlider = () => requestAnimationFrame(updateLangSlider);
    scheduleLangSlider();
    recLangRadios.forEach(input => {
      input.addEventListener('change', scheduleLangSlider);
      input.addEventListener('focus', scheduleLangSlider);
    });
    window.addEventListener('resize', scheduleLangSlider);
  }

  if (langToggleEl && langSliderEl) {
    const langOptions = Array.from(langToggleEl.querySelectorAll('.lang-toggle__option'));
    const langDragState = { active:false, pointerId:null, rect:null, paddingLeft:0, paddingRight:0, borderLeft:0, borderRight:0, hover:null };

    const ensureMetrics = () => {
      langDragState.rect = langToggleEl.getBoundingClientRect();
      const styles = getComputedStyle(langToggleEl);
      langDragState.paddingLeft = parseFloat(styles.paddingLeft) || 0;
      langDragState.paddingRight = parseFloat(styles.paddingRight) || 0;
      langDragState.borderLeft = parseFloat(styles.borderLeftWidth) || 0;
      langDragState.borderRight = parseFloat(styles.borderRightWidth) || 0;
    };

    const commitOption = (label) => {
      if(!label) return;
      const id = label.getAttribute('for');
      if(!id) return;
      const input = langToggleEl.querySelector(`#${id}`);
      if(input && !input.checked){
        input.checked = true;
        input.dispatchEvent(new Event('change', { bubbles:true }));
      }
    };

    const updateDragVisual = (clientX, commit = false) => {
      if(!langDragState.rect) ensureMetrics();
      const { rect, paddingLeft, paddingRight, borderLeft, borderRight } = langDragState;
      if(!rect) return;
      const innerWidth = rect.width - paddingLeft - paddingRight - borderLeft - borderRight;
      if(innerWidth <= 0) return;
      let x = clientX - rect.left - borderLeft - paddingLeft;
      x = Math.max(0, Math.min(innerWidth, x));
      let closestLabel = null;
      let minDist = Infinity;
      langOptions.forEach(label => {
        const optionRect = label.getBoundingClientRect();
        const center = optionRect.left - rect.left - borderLeft - paddingLeft + optionRect.width / 2;
        const dist = Math.abs(center - x);
        if(dist < minDist){
          minDist = dist;
          closestLabel = label;
        }
      });
      if(!closestLabel) return;
      if(langDragState.hover && langDragState.hover !== closestLabel){
        langDragState.hover.classList.remove('is-hovered');
      }
      closestLabel.classList.add('is-hovered');
      langDragState.hover = closestLabel;
      const optionRect = closestLabel.getBoundingClientRect();
      const sliderWidth = optionRect.width;
      const maxOffset = Math.max(0, innerWidth - sliderWidth);
      const offset = Math.max(0, Math.min(x - sliderWidth / 2, maxOffset));
      langToggleEl.style.setProperty('--slider-width', `${sliderWidth}px`);
      langToggleEl.style.setProperty('--slider-offset', `${offset}px`);
      if(commit){
        commitOption(closestLabel);
        requestAnimationFrame(updateLangSlider);
      }
    };

    const finishDrag = () => {
      if(langDragState.pointerId !== null){
        try{ langToggleEl.releasePointerCapture(langDragState.pointerId); }catch(_err){}
      }
      langDragState.pointerId = null;
      langDragState.active = false;
      langToggleEl.classList.remove('lang-toggle--dragging');
      if(langDragState.hover){
        langDragState.hover.classList.remove('is-hovered');
        langDragState.hover = null;
      }
      langDragState.rect = null;
      requestAnimationFrame(updateLangSlider);
    };

    let langSwipeStart = 0;
    const handlePointerMove = (ev) => {
      if(!langDragState.active || (langDragState.pointerId !== null && ev.pointerId !== langDragState.pointerId)) return;
      updateDragVisual(ev.clientX, false);
      
      // Track swipe for navigation
      const delta = ev.clientX - langSwipeStart;
      if(Math.abs(delta) > 50){
        const currentIndex = recLangRadios.findIndex(r => r.checked);
        if(delta > 0 && currentIndex > 0){
          // Swipe right: previous option
          recLangRadios[currentIndex - 1].checked = true;
          recLangRadios[currentIndex - 1].dispatchEvent(new Event('change', {bubbles: true}));
          langSwipeStart = ev.clientX;
        } else if(delta < 0 && currentIndex < recLangRadios.length - 1){
          // Swipe left: next option
          recLangRadios[currentIndex + 1].checked = true;
          recLangRadios[currentIndex + 1].dispatchEvent(new Event('change', {bubbles: true}));
          langSwipeStart = ev.clientX;
        }
      }
    };

    const handlePointerUp = (ev) => {
      if(!langDragState.active || (langDragState.pointerId !== null && ev.pointerId !== langDragState.pointerId)) return;
      updateDragVisual(ev.clientX, true);
      if(langSliderEl){
        langSliderEl.style.transform = '';
      }
      finishDrag();
    };

    langToggleEl.addEventListener('pointerdown', (ev) => {
      if(ev.pointerType === 'mouse' && ev.button !== 0) return;
      const optionLabel = ev.target.closest('label.lang-toggle__option');
      if(ev.pointerType === 'mouse' && optionLabel && langToggleEl.contains(optionLabel)){
        return;
      }
      ensureMetrics();
      langDragState.active = true;
      langDragState.pointerId = ev.pointerId;
      langSwipeStart = ev.clientX;
      langToggleEl.classList.add('lang-toggle--dragging');
      try{ langToggleEl.setPointerCapture(ev.pointerId); }catch(_err){}
      updateDragVisual(ev.clientX, false);
      if(ev.pointerType !== 'mouse'){
        ev.preventDefault();
      }
    });
    langToggleEl.addEventListener('pointermove', handlePointerMove);
    langToggleEl.addEventListener('pointerup', handlePointerUp);
    langToggleEl.addEventListener('pointercancel', handlePointerUp);
    langToggleEl.addEventListener('lostpointercapture', finishDrag);
  }
  const getSelectedLang = () => {
    const active = recLangRadios.find(input => input.checked);
    return active ? active.value : 'en-US';
  };
  const btnMicStart = document.getElementById('btnMicStart');
  const btnMicStop = document.getElementById('btnMicStop');
  
  // Scroll toggle (auto/manual)
  const scrollModeRadios = Array.from(document.querySelectorAll('input[name="scrollMode"]'));
  const scrollToggleEl = document.querySelector('.scroll-toggle');
  const scrollSliderEl = scrollToggleEl ? scrollToggleEl.querySelector('.scroll-toggle__slider') : null;
  let autoScrollEnabled = true;
  
  const updateScrollSlider = () => {
    if (!scrollToggleEl || !scrollSliderEl) return;
    const activeInput = scrollToggleEl.querySelector('input[type="radio"]:checked');
    if (!activeInput) return;
    const activeLabel = scrollToggleEl.querySelector(`label[for="${activeInput.id}"]`);
    if (!activeLabel) return;
    const scrollRect = scrollToggleEl.getBoundingClientRect();
    const labelRect = activeLabel.getBoundingClientRect();
    if (!labelRect.width) return;
    const styles = getComputedStyle(scrollToggleEl);
    const paddingLeft = parseFloat(styles.paddingLeft) || 0;
    const borderLeft = parseFloat(styles.borderLeftWidth) || 0;
    const offset = labelRect.left - scrollRect.left - borderLeft - paddingLeft;
    scrollToggleEl.style.setProperty('--scroll-slider-offset', `${offset}px`);
    scrollToggleEl.style.setProperty('--scroll-slider-width', `${labelRect.width}px`);
  };
  
  if (scrollToggleEl && scrollSliderEl) {
    const scheduleScrollSlider = () => requestAnimationFrame(updateScrollSlider);
    scheduleScrollSlider();
    scrollModeRadios.forEach(input => {
      input.addEventListener('change', () => {
        autoScrollEnabled = input.value === 'auto';
        scheduleScrollSlider();
      });
      input.addEventListener('focus', scheduleScrollSlider);
    });
    window.addEventListener('resize', scheduleScrollSlider);
    
    // Draggable scroll toggle
    const scrollOptions = Array.from(scrollToggleEl.querySelectorAll('.scroll-toggle__option'));
    const scrollDragState = { active:false, pointerId:null, rect:null, paddingLeft:0, paddingRight:0, borderLeft:0, borderRight:0, hover:null };

    const ensureScrollMetrics = () => {
      scrollDragState.rect = scrollToggleEl.getBoundingClientRect();
      const styles = getComputedStyle(scrollToggleEl);
      scrollDragState.paddingLeft = parseFloat(styles.paddingLeft) || 0;
      scrollDragState.paddingRight = parseFloat(styles.paddingRight) || 0;
      scrollDragState.borderLeft = parseFloat(styles.borderLeftWidth) || 0;
      scrollDragState.borderRight = parseFloat(styles.borderRightWidth) || 0;
    };

    const commitScrollOption = (label) => {
      if(!label) return;
      const id = label.getAttribute('for');
      if(!id) return;
      const input = scrollToggleEl.querySelector(`#${id}`);
      if(input && !input.checked){
        input.checked = true;
        input.dispatchEvent(new Event('change', {bubbles: true}));
      }
    };

    const updateScrollDragVisual = (clientX, commit = false) => {
      if(!scrollDragState.rect) ensureScrollMetrics();
      const { rect, paddingLeft, paddingRight, borderLeft, borderRight } = scrollDragState;
      if(!rect) return;
      const innerWidth = rect.width - paddingLeft - paddingRight - borderLeft - borderRight;
      if(innerWidth <= 0) return;
      let x = clientX - rect.left - borderLeft - paddingLeft;
      x = Math.max(0, Math.min(innerWidth, x));
      let closestLabel = null;
      let minDist = Infinity;
      scrollOptions.forEach(label => {
        const optionRect = label.getBoundingClientRect();
        const center = optionRect.left - rect.left - borderLeft - paddingLeft + optionRect.width / 2;
        const dist = Math.abs(center - x);
        if(dist < minDist){
          minDist = dist;
          closestLabel = label;
        }
      });
      if(!closestLabel) return;
      if(scrollDragState.hover && scrollDragState.hover !== closestLabel){
        scrollDragState.hover.classList.remove('is-hovered');
      }
      closestLabel.classList.add('is-hovered');
      scrollDragState.hover = closestLabel;
      const optionRect = closestLabel.getBoundingClientRect();
      const sliderWidth = optionRect.width;
      const maxOffset = Math.max(0, innerWidth - sliderWidth);
      const offset = Math.max(0, Math.min(x - sliderWidth / 2, maxOffset));
      scrollToggleEl.style.setProperty('--scroll-slider-width', `${sliderWidth}px`);
      scrollToggleEl.style.setProperty('--scroll-slider-offset', `${offset}px`);
      if(commit){
        commitScrollOption(closestLabel);
        requestAnimationFrame(updateScrollSlider);
      }
    };

    const finishScrollDrag = () => {
      if(scrollDragState.pointerId !== null){
        try{ scrollToggleEl.releasePointerCapture(scrollDragState.pointerId); }catch(_err){}
      }
      scrollDragState.pointerId = null;
      scrollDragState.active = false;
      scrollToggleEl.classList.remove('scroll-toggle--dragging');
      if(scrollDragState.hover){
        scrollDragState.hover.classList.remove('is-hovered');
        scrollDragState.hover = null;
      }
      scrollDragState.rect = null;
      requestAnimationFrame(updateScrollSlider);
    };

    const handleScrollPointerMove = (ev) => {
      if(!scrollDragState.active || (scrollDragState.pointerId !== null && ev.pointerId !== scrollDragState.pointerId)) return;
      updateScrollDragVisual(ev.clientX, false);
    };

    const handleScrollPointerUp = (ev) => {
      if(!scrollDragState.active || (scrollDragState.pointerId !== null && ev.pointerId !== scrollDragState.pointerId)) return;
      updateScrollDragVisual(ev.clientX, true);
      if(scrollSliderEl){
        scrollSliderEl.style.transform = '';
      }
      finishScrollDrag();
    };

    scrollToggleEl.addEventListener('pointerdown', (ev) => {
      if(ev.pointerType === 'mouse' && ev.button !== 0) return;
      const optionLabel = ev.target.closest('label.scroll-toggle__option');
      if(ev.pointerType === 'mouse' && optionLabel && scrollToggleEl.contains(optionLabel)){
        return;
      }
      ensureScrollMetrics();
      scrollDragState.active = true;
      scrollDragState.pointerId = ev.pointerId;
      scrollToggleEl.classList.add('scroll-toggle--dragging');
      try{ scrollToggleEl.setPointerCapture(ev.pointerId); }catch(_err){}
      updateScrollDragVisual(ev.clientX, false);
      if(ev.pointerType !== 'mouse'){
        ev.preventDefault();
      }
    });
    scrollToggleEl.addEventListener('pointermove', handleScrollPointerMove);
    scrollToggleEl.addEventListener('pointerup', handleScrollPointerUp);
    scrollToggleEl.addEventListener('pointercancel', handleScrollPointerUp);
    scrollToggleEl.addEventListener('lostpointercapture', finishScrollDrag);
  }
  const recModeRadios = Array.from(document.querySelectorAll('input[name=\"recMode\"]'));
  const modeToggleEl = document.querySelector('.mode-toggle');
  const modeSliderEl = modeToggleEl ? modeToggleEl.querySelector('.mode-toggle__slider') : null;
  
  const updateModeSlider = () => {
    if (!modeToggleEl || !modeSliderEl) return;
    const activeInput = modeToggleEl.querySelector('input[type="radio"]:checked');
    if (!activeInput) return;
    const activeLabel = modeToggleEl.querySelector(`label[for="${activeInput.id}"]`);
    if (!activeLabel) return;
    const modeRect = modeToggleEl.getBoundingClientRect();
    const labelRect = activeLabel.getBoundingClientRect();
    if (!labelRect.width) return;
    const styles = getComputedStyle(modeToggleEl);
    const paddingLeft = parseFloat(styles.paddingLeft) || 0;
    const borderLeft = parseFloat(styles.borderLeftWidth) || 0;
    const offset = labelRect.left - modeRect.left - borderLeft - paddingLeft;
    modeToggleEl.style.setProperty('--mode-slider-offset', `${offset}px`);
    modeToggleEl.style.setProperty('--mode-slider-width', `${labelRect.width}px`);
  };
  if (modeToggleEl && modeSliderEl) {
    const scheduleModeSlider = () => requestAnimationFrame(updateModeSlider);
    scheduleModeSlider();
    recModeRadios.forEach(input => {
      input.addEventListener('change', scheduleModeSlider);
      input.addEventListener('focus', scheduleModeSlider);
    });
    window.addEventListener('resize', scheduleModeSlider);
    
    // Draggable mode toggle with pointer tracking (same as language)
    const modeOptions = Array.from(modeToggleEl.querySelectorAll('.mode-toggle__option'));
    const modeDragState = { active:false, pointerId:null, rect:null, paddingLeft:0, paddingRight:0, borderLeft:0, borderRight:0, hover:null };

    const ensureModeMetrics = () => {
      modeDragState.rect = modeToggleEl.getBoundingClientRect();
      const styles = getComputedStyle(modeToggleEl);
      modeDragState.paddingLeft = parseFloat(styles.paddingLeft) || 0;
      modeDragState.paddingRight = parseFloat(styles.paddingRight) || 0;
      modeDragState.borderLeft = parseFloat(styles.borderLeftWidth) || 0;
      modeDragState.borderRight = parseFloat(styles.borderRightWidth) || 0;
    };

    const commitModeOption = (label) => {
      if(!label) return;
      const id = label.getAttribute('for');
      if(!id) return;
      const input = modeToggleEl.querySelector(`#${id}`);
      if(input && !input.checked){
        input.checked = true;
        input.dispatchEvent(new Event('change', {bubbles: true}));
      }
    };

    const updateModeDragVisual = (clientX, commit = false) => {
      if(!modeDragState.rect) ensureModeMetrics();
      const { rect, paddingLeft, paddingRight, borderLeft, borderRight } = modeDragState;
      if(!rect) return;
      const innerWidth = rect.width - paddingLeft - paddingRight - borderLeft - borderRight;
      if(innerWidth <= 0) return;
      let x = clientX - rect.left - borderLeft - paddingLeft;
      x = Math.max(0, Math.min(innerWidth, x));
      let closestLabel = null;
      let minDist = Infinity;
      modeOptions.forEach(label => {
        const optionRect = label.getBoundingClientRect();
        const center = optionRect.left - rect.left - borderLeft - paddingLeft + optionRect.width / 2;
        const dist = Math.abs(center - x);
        if(dist < minDist){
          minDist = dist;
          closestLabel = label;
        }
      });
      if(!closestLabel) return;
      if(modeDragState.hover && modeDragState.hover !== closestLabel){
        modeDragState.hover.classList.remove('is-hovered');
      }
      closestLabel.classList.add('is-hovered');
      modeDragState.hover = closestLabel;
      const optionRect = closestLabel.getBoundingClientRect();
      const sliderWidth = optionRect.width;
      const maxOffset = Math.max(0, innerWidth - sliderWidth);
      const offset = Math.max(0, Math.min(x - sliderWidth / 2, maxOffset));
      modeToggleEl.style.setProperty('--mode-slider-width', `${sliderWidth}px`);
      modeToggleEl.style.setProperty('--mode-slider-offset', `${offset}px`);
      if(commit){
        commitModeOption(closestLabel);
        requestAnimationFrame(updateModeSlider);
      }
    };

    const finishModeDrag = () => {
      if(modeDragState.pointerId !== null){
        try{ modeToggleEl.releasePointerCapture(modeDragState.pointerId); }catch(_err){}
      }
      modeDragState.pointerId = null;
      modeDragState.active = false;
      modeToggleEl.classList.remove('mode-toggle--dragging');
      if(modeDragState.hover){
        modeDragState.hover.classList.remove('is-hovered');
        modeDragState.hover = null;
      }
      modeDragState.rect = null;
      requestAnimationFrame(updateModeSlider);
    };

    const handleModePointerMove = (ev) => {
      if(!modeDragState.active || (modeDragState.pointerId !== null && ev.pointerId !== modeDragState.pointerId)) return;
      updateModeDragVisual(ev.clientX, false);
    };

    const handleModePointerUp = (ev) => {
      if(!modeDragState.active || (modeDragState.pointerId !== null && ev.pointerId !== modeDragState.pointerId)) return;
      updateModeDragVisual(ev.clientX, true);
      if(modeSliderEl){
        modeSliderEl.style.transform = '';
      }
      finishModeDrag();
    };

    modeToggleEl.addEventListener('pointerdown', (ev) => {
      if(ev.pointerType === 'mouse' && ev.button !== 0) return;
      const optionLabel = ev.target.closest('label.mode-toggle__option');
      if(ev.pointerType === 'mouse' && optionLabel && modeToggleEl.contains(optionLabel)){
        return;
      }
      ensureModeMetrics();
      modeDragState.active = true;
      modeDragState.pointerId = ev.pointerId;
      modeToggleEl.classList.add('mode-toggle--dragging');
      try{ modeToggleEl.setPointerCapture(ev.pointerId); }catch(_err){}
      updateModeDragVisual(ev.clientX, false);
      if(ev.pointerType !== 'mouse'){
        ev.preventDefault();
      }
    });
    modeToggleEl.addEventListener('pointermove', handleModePointerMove);
    modeToggleEl.addEventListener('pointerup', handleModePointerUp);
    modeToggleEl.addEventListener('pointercancel', handleModePointerUp);
    modeToggleEl.addEventListener('lostpointercapture', finishModeDrag);
  }

  function updateProgressIndicator(){
    // Progress indicator removed for simplified UI
  }

  function updateRealtimeTelemetry(){
    // Telemetry indicators removed for simplified UI
  }

  function updateSessionMeta(){
    // Session meta pills removed for simplified UI
  }


  // ====== Èü≥Â£∞Ë™çË≠òÔºàË™≠„Åø‰∏ä„Åí„Å™„ÅóÔºâ ======
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

  // ====== Áä∂ÊÖã ======
  let tokens = [];           // {text, type: 'word'|'ws', start}
  let wordStarts = [];       // word token „ÅÆÈñãÂßã„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
  let currentWord = -1;      // ÁèæÂú®„Éè„Ç§„É©„Ç§„Éà„Åó„Å¶„ÅÑ„Çã word index
  let recognizing = false;   // mic Áä∂ÊÖã
  let lastMicIndex = -1;     // „Éû„Ç§„ÇØ„ÅßÈÄ≤„Çì„Å†„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
  let recognizer = null;
  let normalizedWords = [];
  let wordStates = [];
  let lastResultKey = '';
  let unmatchedCount = 0;
  let pendingGap = false;
  let lastSourceText = '';
  let shouldAutoRestart = false;
  let userStopRequested = false;
  let restartTimer = null;
  let idleTimer = null;
  let lastTranscriptTimestamp = 0;
  let recognitionSession = {resume:false, fromRestart:false};
  let permissionPrimed = false;
  let recognitionMode = 'precise';
  let lastSpeedNorm = '';
  let speedState = { history: [], map: [], lastReliable: -1, anchor: -1, missCount: 0, stability: 0, lastInputTs: 0, lastEmitTs: 0 };

  // ====== „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ ======
  function normalizeForMatch(str){
    try{
      return str.toLowerCase().replace(/[\u2019\u2018]/g, "'")
        .replace(/[^\p{L}\p{N}'\s]+/gu, ' ').replace(/\s+/g, ' ').trim();
    }catch(e){
      return str.toLowerCase().replace(/[^a-z0-9'\s]+/g, ' ').replace(/\s+/g, ' ').trim();
    }
  }

  function tokenize(text){
    tokens = []; wordStarts = []; normalizedWords = []; lastResultKey = ''; unmatchedCount = 0; pendingGap = false;
    shouldAutoRestart = false; userStopRequested = false;
    clearRestartTimer(); clearIdleGuard();
    lastTranscriptTimestamp = 0;
    lastSpeedNorm = '';
    resetSpeedState();
    let i = 0;
    while(i < text.length){
      if(/\s/.test(text[i])){
        let j = i+1; while(j < text.length && /\s/.test(text[j])) j++;
        tokens.push({text:text.slice(i,j), type:'ws', start:i});
        i = j;
      }else{
        let j = i+1; while(j < text.length && !/\s/.test(text[j])) j++;
        const wordText = text.slice(i,j);
        tokens.push({text:wordText, type:'word', start:i});
        wordStarts.push(i);
        normalizedWords.push(normalizeForMatch(wordText));
        i = j;
      }
    }
    lastSourceText = text;
    wordStates = new Array(normalizedWords.length).fill('pending');
  }

  function render(){
    const frag = document.createDocumentFragment();
    tokens.forEach((tok, k)=>{
      if(tok.type === 'word'){
        const span = document.createElement('span');
        span.className = 'word';
        span.dataset.i = wordIndexFromTokenIndex(k);
        span.textContent = tok.text;
        span.addEventListener('click', ()=>{
          highlightTo(parseInt(span.dataset.i,10), { manual:true });
        });
        frag.appendChild(span);
      }else{
        frag.appendChild(document.createTextNode(tok.text));
      }
    });
    reader.innerHTML = '';
    reader.appendChild(frag);
    const spans = getWordSpans();
    if(wordStates.length !== spans.length){
      wordStates = new Array(spans.length).fill('pending');
    }
    spans.forEach((span, idx)=>{
      applySpanState(span, wordStates[idx] || 'pending');
    });
    currentWord = -1;
    lastMicIndex = -1;
    pendingGap = false;
    unmatchedCount = 0;
    updateProgressIndicator();
  }

  function getWordSpans(){
    return reader.querySelectorAll('.word');
  }

  function applySpanState(span, state){
    span.classList.toggle('word--matched', state === 'matched');
    span.classList.toggle('word--missed', state === 'missed');
    span.classList.toggle('word--pending', state === 'pending');
  }

  function updateWordState(index, state, spans){
    if(index < 0 || index >= wordStates.length) return;
    wordStates[index] = state;
    const list = spans || getWordSpans();
    const span = list[index];
    if(span) applySpanState(span, state);
  }

  function updateWordStateRange(from, to, state, spans){
    if(!wordStates.length) return;
    const list = spans || getWordSpans();
    const start = Math.max(0, from);
    const end = Math.min(wordStates.length - 1, to);
    if(end < start) return;
    for(let i=start; i<=end; i++){
      wordStates[i] = state;
      const span = list[i];
      if(span) applySpanState(span, state);
    }
  }

  function resetAllWordStates(){
    wordStates = new Array(normalizedWords.length).fill('pending');
    const spans = getWordSpans();
    spans.forEach(span=>applySpanState(span, 'pending'));
    updateProgressIndicator();
  }

  function resetSpeedState(){
    speedState = { history: [], map: [], lastReliable: -1, anchor: -1, missCount: 0, stability: 0, lastInputTs: 0, lastEmitTs: 0 };
    updateRealtimeTelemetry();
  }

  function rewindHighlight(targetIndex){
    const spans = getWordSpans();
    const clamped = Math.min(Math.max(targetIndex, -1), spans.length - 1);
    for(let i=clamped + 1; i<wordStates.length; i++){
      if(wordStates[i] !== 'pending'){
        wordStates[i] = 'pending';
      }
      const span = spans[i];
      if(span){
        applySpanState(span, 'pending');
        span.classList.remove('word--active', 'active');
      }
    }
    if(currentWord >= 0 && currentWord < spans.length){
      spans[currentWord].classList.remove('word--active', 'active');
    }
    currentWord = clamped;
    lastMicIndex = clamped;
    if(clamped >= 0){
      spans[clamped].classList.add('word--active', 'active');
      if(autoScrollEnabled){
        spans[clamped].scrollIntoView({block:'center', behavior:'smooth'});
      }
    }
    updateProgressIndicator();
  }

  function alignSpeedWindow(parts, baseIndex, hasFinal){
    if(parts.length === 0 || !normalizedWords.length) return null;
    const anchor = baseIndex >= 0 ? baseIndex : (currentWord >= 0 ? currentWord : -1);
    const dynamicAhead = hasFinal ? 30 : 22;
    const windowStart = Math.max(0, (anchor >= 0 ? anchor : 0) - 6);
    const windowEnd = Math.min(
      normalizedWords.length - 1,
      Math.max(anchor + 1, currentWord + 1, 0) + dynamicAhead
    );
    if(windowEnd < windowStart) return null;
    const windowWords = normalizedWords.slice(windowStart, windowEnd + 1);
    if(!windowWords.length) return null;

    const rows = parts.length + 1;
    const cols = windowWords.length + 1;
    const NEG = -1e9;
    const dp = Array.from({length: rows}, () => new Float32Array(cols).fill(NEG));
    const bt = Array.from({length: rows}, () => new Array(cols));
    const skipWordPenalty = hasFinal ? 1.2 : 0.9;
    const skipPartPenalty = hasFinal ? 1.05 : 0.75;

    dp[0][0] = 0;
    for(let j=1; j<cols; j++){
      dp[0][j] = dp[0][j-1] - skipWordPenalty;
      bt[0][j] = { i:0, j:j-1, type:'skipWord' };
    }
    for(let i=1; i<rows; i++){
      dp[i][0] = dp[i-1][0] - skipPartPenalty;
      bt[i][0] = { i:i-1, j:0, type:'skipPart' };
    }

    for(let i=1; i<rows; i++){
      const part = parts[i-1];
      for(let j=1; j<cols; j++){
        const word = windowWords[j-1];
        let rawScore = scoreWordMatch(word, part);
        if(rawScore <= -50) rawScore = -6;
        else if(rawScore < 0) rawScore = rawScore / 4;
        let bestScore = dp[i-1][j-1] + rawScore;
        let bestStep = { i:i-1, j:j-1, type:'match' };
        const skipWordScore = dp[i][j-1] - skipWordPenalty;
        if(skipWordScore > bestScore){
          bestScore = skipWordScore;
          bestStep = { i:i, j:j-1, type:'skipWord' };
        }
        const skipPartScore = dp[i-1][j] - skipPartPenalty;
        if(skipPartScore > bestScore){
          bestScore = skipPartScore;
          bestStep = { i:i-1, j:j, type:'skipPart' };
        }
        dp[i][j] = bestScore;
        bt[i][j] = bestStep;
      }
    }

    let bestCol = 0;
    let bestScore = -Infinity;
    const lastRow = rows - 1;
    for(let j=1; j<cols; j++){
      const wordIdx = windowStart + j - 1;
      const distance = anchor >= 0 ? Math.max(0, wordIdx - anchor) : Math.max(0, wordIdx);
      const penalty = distance > 0 ? Math.log2(distance + 1) * 0.35 : 0;
      const score = dp[lastRow][j] - penalty;
      if(score > bestScore){
        bestScore = score;
        bestCol = j;
      }
    }

    const mapping = new Array(parts.length).fill(-1);
    const matchedWords = [];
    let strongMatches = 0;
    let softMatches = 0;
    let i = rows - 1;
    let j = bestCol;
    while(i > 0 || j > 0){
      const step = bt[i][j];
      if(!step) break;
      if(step.type === 'match'){
        const partIdx = i - 1;
        const wordIdx = windowStart + j - 1;
        const rawScore = scoreWordMatch(windowWords[j-1], parts[i-1]);
        mapping[partIdx] = wordIdx;
        if(rawScore >= 1){
          matchedWords.push(wordIdx);
          strongMatches++;
        }else if(rawScore >= 0.5){
          matchedWords.push(wordIdx);
          softMatches++;
        }
        i = step.i;
        j = step.j;
      }else{
        i = step.i;
        j = step.j;
      }
    }

    const uniqueMatches = Array.from(new Set(matchedWords));
    const bestIndex = mapping.reduce((acc, val) => (typeof val === 'number' && val > acc) ? val : acc, -1);
    const effectiveMatches = strongMatches + softMatches * 0.5;
    const coverage = effectiveMatches / Math.max(1, parts.length);
    const rawPathScore = dp[rows - 1][bestCol];
    const scorePerToken = rawPathScore / Math.max(1, parts.length);
    const unmatchedParts = parts.length - (strongMatches + softMatches);
    return {
      mapping,
      matchedWords: uniqueMatches,
      bestIndex,
      coverage,
      scorePerToken,
      score: bestScore,
      unmatchedParts
    };
  }

  function findRealtimeCandidate(contextParts, anchor, options = {}){
    if(!contextParts.length || !normalizedWords.length) return null;
    const hasFinal = !!options.hasFinal;
    const windowAhead = typeof options.windowAhead === 'number' ? options.windowAhead : 14;
    const backtrack = typeof options.backtrack === 'number' ? options.backtrack : 2;
    let startIndex = anchor < 0 ? 0 : Math.max(0, anchor - backtrack);
    let endIndex = normalizedWords.length - 1;
    if(anchor >= 0){
      endIndex = Math.min(normalizedWords.length - 1, anchor + windowAhead);
    }else{
      endIndex = Math.min(normalizedWords.length - 1, windowAhead);
    }
    if(endIndex < startIndex) return null;

    let bestIndex = -1;
    let bestScore = -Infinity;
    let bestQuality = 0;

    for(let idx = startIndex; idx <= endIndex; idx++){
      if(idx < contextParts.length - 1) continue;
      const wordStart = idx - (contextParts.length - 1);
      if(wordStart < 0) continue;
      let score = 0;
      let valid = true;
      for(let j=0; j<contextParts.length; j++){
        const tokenScore = scoreWordMatch(normalizedWords[wordStart + j], contextParts[j]);
        if(tokenScore < 0){
          valid = false;
          break;
        }
        score += tokenScore;
      }
      if(!valid) continue;
      const avgScore = score / contextParts.length;
      const distance = anchor < 0 ? idx : Math.max(0, idx - anchor);
      const penalty = distance > 0 ? (distance * (hasFinal ? 0.16 : 0.32) + Math.log2(distance + 1) * (hasFinal ? 0.22 : 0.4)) : 0;
      const bonus = hasFinal ? contextParts.length * 0.12 : 0;
      const finalScore = score - penalty + bonus;
      if(finalScore > bestScore){
        bestScore = finalScore;
        bestIndex = idx;
        bestQuality = avgScore;
      }
    }

    if(bestIndex === -1) return null;
    const qualityThreshold = hasFinal ? 0.8 : 1.05;
    if(bestQuality < qualityThreshold) return null;
    if(!hasFinal && anchor >= 0 && bestIndex <= anchor) return null;
    return { index: bestIndex, score: bestScore, quality: bestQuality };
  }

  function processSpeedRecognition(parts, hasFinal){
    if(!normalizedWords.length) return;
    if(!parts.length){
      speedState.history = [];
      speedState.map = [];
      speedState.anchor = Math.max(currentWord, speedState.lastReliable);
      speedState.missCount = 0;
      speedState.stability = Math.max(0, speedState.stability * 0.5);
      updateRealtimeTelemetry();
      return;
    }

    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    speedState.lastInputTs = now;

    const prevHistory = speedState.history;
    const prevMap = speedState.map;
    const maxPrefix = Math.min(prevHistory.length, parts.length);
    let prefix = 0;
    while(prefix < maxPrefix && prevHistory[prefix] === parts[prefix]) prefix++;

    if(prefix < prevHistory.length){
      const rollbackIndex = prefix > 0 ? prevMap[prefix - 1] : -1;
      highlightTo(rollbackIndex, { outcome:'rollback' });
      speedState.anchor = rollbackIndex;
      speedState.lastReliable = rollbackIndex;
      speedState.missCount = 0;
      speedState.map = prevMap.slice(0, prefix);
      speedState.history = prevHistory.slice(0, prefix);
    }else{
      speedState.map = prevMap.slice(0, prefix);
      speedState.history = prevHistory.slice(0, prefix);
    }

    let anchor = speedState.anchor;
    if(typeof anchor !== 'number' || anchor < -1){
      anchor = -1;
    }
    if(speedState.map.length){
      const lastAssigned = speedState.map[speedState.map.length - 1];
      if(typeof lastAssigned === 'number'){
        anchor = lastAssigned;
      }
    }
    if(anchor < currentWord) anchor = currentWord;
    if(speedState.lastReliable > anchor) anchor = speedState.lastReliable;

    let fallbackNeeded = false;
    const windowAhead = hasFinal ? 26 : 14;

    for(let idx = prefix; idx < parts.length; idx++){
      const tailStart = Math.max(0, idx - 3);
      const tail = parts.slice(tailStart, idx + 1);
      const candidate = findRealtimeCandidate(tail, anchor, { hasFinal, windowAhead });
      if(candidate){
        const strongThreshold = hasFinal ? 1.05 : 1.35;
        const softThreshold = hasFinal ? 0.85 : 1.1;
        let outcome = 'match';
        let markSkipped = candidate.quality >= strongThreshold;
        if(candidate.quality < softThreshold){
          outcome = 'skip';
          markSkipped = false;
        }
        highlightTo(candidate.index, { outcome, markSkipped });
        speedState.map[idx] = candidate.index;
        anchor = candidate.index;
        speedState.anchor = anchor;
        speedState.lastReliable = Math.max(speedState.lastReliable, candidate.index);
        speedState.missCount = 0;
        const commitTime = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        speedState.lastEmitTs = commitTime;
        const stabilityBoost = outcome === 'match' ? (markSkipped ? 0.5 : 0.35) : 0.25;
        speedState.stability = Math.min(1, speedState.stability * 0.55 + stabilityBoost);
        updateRealtimeTelemetry();
      }else{
        speedState.map[idx] = -1;
        speedState.missCount = (speedState.missCount || 0) + 1;
        speedState.stability = Math.max(0, speedState.stability * 0.6 - 0.12);
        if(speedState.missCount >= (hasFinal ? 2 : 3)){
          fallbackNeeded = true;
          break;
        }
      }
    }

    if(speedState.map.length < parts.length){
      for(let i = speedState.map.length; i < parts.length; i++){
        speedState.map[i] = -1;
      }
    }

    speedState.anchor = anchor;

    if(fallbackNeeded || (hasFinal && (speedState.map[parts.length - 1] ?? -1) === -1)){
      const tailLimit = hasFinal ? 30 : 18;
      const tailParts = parts.slice(-tailLimit);
      const baseIndex = Math.max(anchor, speedState.lastReliable, currentWord);
      const alignment = alignSpeedWindow(tailParts, baseIndex, hasFinal);
      if(alignment && typeof alignment.bestIndex === 'number' && alignment.bestIndex !== -1 && alignment.bestIndex >= anchor){
        highlightTo(alignment.bestIndex, { outcome:'match' });
        speedState.anchor = alignment.bestIndex;
        speedState.lastReliable = alignment.bestIndex;
        speedState.map[parts.length - 1] = alignment.bestIndex;
        speedState.missCount = 0;
        const commitTime = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        speedState.lastEmitTs = commitTime;
        speedState.stability = Math.min(1, speedState.stability * 0.55 + 0.45);
        updateRealtimeTelemetry();
      }
    }

    speedState.history = parts.slice();
    if(speedState.map.length > parts.length){
      speedState.map.length = parts.length;
    }
    updateRealtimeTelemetry();
  }

  function wordIndexFromTokenIndex(tokenIdx){
    let count = 0; for(let i=0;i<=tokenIdx;i++) if(tokens[i].type==='word') count++; return count-1;
  }

  function highlightTo(index, options = {}){
    const { manual = false, outcome = 'match', markSkipped = true } = options;
    const wordSpans = getWordSpans();
    if(outcome === 'rollback' && !manual){
      rewindHighlight(index);
      pendingGap = false;
      unmatchedCount = 0;
      return;
    }
    if(index < 0 || index >= wordSpans.length) return;
    if(!manual){
      const prev = currentWord;
      if(outcome === 'match'){
        if(markSkipped){
          const start = prev >= 0 ? prev + 1 : 0;
          if(index - start > 0){
            updateWordStateRange(start, index - 1, 'missed', wordSpans);
          }
        }
        updateWordState(index, 'matched', wordSpans);
        speedState.lastReliable = Math.max(speedState.lastReliable, index);
      }else if(outcome === 'skip'){
        if(markSkipped){
          const from = prev < index ? prev + 1 : index;
          updateWordStateRange(from, index, 'missed', wordSpans);
        }
      }
    }
    if(currentWord >= 0 && currentWord < wordSpans.length){
      wordSpans[currentWord].classList.remove('word--active', 'active');
    }
    wordSpans[index].classList.add('word--active', 'active');
    currentWord = index;
    lastMicIndex = index;
    pendingGap = false;
    unmatchedCount = 0;
    updateProgressIndicator();
    if(autoScrollEnabled){ wordSpans[index].scrollIntoView({block:'center', behavior:'smooth'}); }
  }

  function clearRestartTimer(){
    if(restartTimer){ clearTimeout(restartTimer); restartTimer = null; }
  }

  function clearIdleGuard(){
    if(idleTimer){ clearTimeout(idleTimer); idleTimer = null; }
  }

  function scheduleIdleGuard(){
    clearIdleGuard();
    idleTimer = setTimeout(()=>{
      if(!recognizing || !shouldAutoRestart || !recognizer) return;
      const elapsed = Date.now() - lastTranscriptTimestamp;
      if(elapsed >= 9000){
        pendingGap = true;
        recognizer.stop();
      }else{
        scheduleIdleGuard();
      }
    }, 4000);
  }

  async function primeMicPermission(){
    if(permissionPrimed) return true;
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return true;
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      stream.getTracks().forEach(track=>track.stop());
      permissionPrimed = true;
      return true;
    }catch(err){
      console.warn('Microphone permission request failed', err);
      return false;
    }
  }

  function levenshtein(a,b){
    const m = a.length, n = b.length;
    if(m === 0) return n;
    if(n === 0) return m;
    const dp = new Array(n + 1);
    for(let j=0;j<=n;j++) dp[j] = j;
    for(let i=1;i<=m;i++){
      let prev = dp[0];
      dp[0] = i;
      for(let j=1;j<=n;j++){
        const temp = dp[j];
        if(a[i-1] === b[j-1]) dp[j] = prev;
        else dp[j] = Math.min(prev, dp[j-1], dp[j]) + 1;
        prev = temp;
      }
    }
    return dp[n];
  }

  function scoreWordMatch(a,b){
    if(!a || !b) return -100;
    if(a === b) return 3;
    if(a.startsWith(b) || b.startsWith(a)) return 2;
    const dist = levenshtein(a,b);
    const minLen = Math.min(a.length, b.length);
    if(dist === 1) return 2;
    if(dist === 2 && minLen > 4) return 1.5;
    if(dist <= Math.ceil(minLen / 2) && minLen >= 6) return 1;
    return -100;
  }

  function findNextWordIndex(parts, baseIndex, lookAhead){
    const maxContext = Math.min(4, parts.length);
    const backtrack = 3;
    for(let context = maxContext; context >= 1; context--){
      const slice = parts.slice(-context);
      const start = Math.max(0, baseIndex + 1 - backtrack);
      const end = Math.min(normalizedWords.length - context + 1, baseIndex + 1 + lookAhead);
      if(end <= start) continue;
      let bestScore = -100;
      let bestIdx = -1;
      for(let i=start; i<end; i++){
        let score = 0;
        for(let j=0; j<context; j++){
          const candidate = normalizedWords[i+j];
          const wordScore = scoreWordMatch(candidate, slice[j]);
          if(wordScore < 0){ score = -100; break; }
          score += wordScore;
        }
        if(score <= -100) continue;
        const candidateIdx = i + context - 1;
        const distance = Math.max(0, candidateIdx - baseIndex);
        const distancePenalty = distance > 0 ? (Math.log2(distance + 1) * 0.8 + distance * 0.3) : 0;
        const finalScore = score - distancePenalty;
        if(finalScore > bestScore){
          bestScore = finalScore;
          bestIdx = candidateIdx;
        }
      }
      const minScore = context * 1.6;
      if(bestIdx !== -1 && bestScore >= minScore){
        return bestIdx;
      }
    }
    return -1;
  }

  function findBestGlobalMatch(parts, baseIndex){
    if(normalizedWords.length === 0) return -1;
    const maxContext = Math.min(4, parts.length);
    const start = Math.max(0, baseIndex + 1);
    let bestIdx = -1;
    let bestScore = -100;
    for(let context = maxContext; context >= 1; context--){
      const slice = parts.slice(-context);
      const end = normalizedWords.length - context + 1;
      if(end <= start) continue;
      for(let i=start; i<end; i++){
        let score = 0;
        for(let j=0; j<context; j++){
          const candidate = normalizedWords[i+j];
          const wordScore = scoreWordMatch(candidate, slice[j]);
          if(wordScore < 0){ score = -100; break; }
          score += wordScore;
        }
        if(score <= -100) continue;
        const candidateIdx = i + context - 1;
        const distance = candidateIdx - baseIndex;
        const penalty = distance > 0 ? (Math.log2(distance + 1) * 1.2 + distance * 0.4) : 0;
        const finalScore = score - penalty;
        if(finalScore > bestScore){
          bestScore = finalScore;
          bestIdx = candidateIdx;
        }
      }
      if(bestIdx !== -1 && bestScore >= context * 1.4){
        return bestIdx;
      }
    }
    return bestScore >= 1.5 ? bestIdx : -1;
  }

  function indexFromChar(charIndex){
    let lo = 0, hi = wordStarts.length - 1, ans = 0;
    while(lo <= hi){
      const mid = (lo + hi) >> 1;
      if(wordStarts[mid] <= charIndex){ ans = mid; lo = mid + 1; }
      else{ hi = mid - 1; }
    }
    return ans;
  }

  // ====== „Éû„Ç§„ÇØËøΩÂæìÔºàÁ∞°ÊòìÔºâ ======
  function ensureRecognizer(){
    if(recognizer) return;
    recognizer = new SpeechRecognition();
    recognizer.continuous = true;
    recognizer.interimResults = true;
    recognizer.onstart = handleRecognizerStart;
    recognizer.onend = handleRecognizerEnd;
    recognizer.onerror = handleRecognizerError;
    recognizer.onresult = handleRecognizerResult;
  }

  async function micStart(options = {}){
    const { resume = false, fromRestart = false } = options;
    if(!SpeechRecognition){ alert('„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„ÅØ SpeechRecognition „Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇChrome/Edge „Çí„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'); return; }
    if(recognizing) return;

    const text = textInput.value.trim();
    if(!text){ alert('„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'); return; }
    if(!resume){
      if(text !== lastSourceText || tokens.length === 0){
        tokenize(text);
        render();
      }else if(!reader.childNodes.length){
        render();
      }
    }

    const permissionOk = await primeMicPermission();
    if(!permissionOk && !permissionPrimed){
      recStatus.textContent = '„Éû„Ç§„ÇØ„ÅåË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì';
      return;
    }

    clearRestartTimer();
    clearIdleGuard();
    shouldAutoRestart = true;
    userStopRequested = false;
    recognitionSession = {resume, fromRestart};

    ensureRecognizer();
    recognizer.lang = getSelectedLang();

    try{
      recognizer.start();
    }catch(err){
      console.error(err);
      recStatus.textContent = 'ÈñãÂßã„Åß„Åç„Åæ„Åõ„Çì: ' + err.message;
      btnMicStart.disabled = false;
      btnMicStop.disabled = true;
      shouldAutoRestart = false;
    }
  }

  function handleRecognizerStart(){
    recognizing = true;
    btnMicStart.disabled = true;
    btnMicStop.disabled = false;
    pendingGap = false;
    unmatchedCount = 0;
    resetSpeedState();
    speedState.lastReliable = currentWord;
    speedState.anchor = currentWord;
    updateRealtimeTelemetry();
    lastTranscriptTimestamp = Date.now();
    scheduleIdleGuard();
    const modePrefix = recognitionMode === 'speed' ? '„ÄêÈ´òÈÄü„Äë' : '„ÄêÊ≠£Á¢∫„Äë';
    if(recognitionSession.fromRestart){
      recStatus.textContent = `${modePrefix}ÂÜçÈñã„Åó„Åæ„Åó„Åü„ÄÇÁ∂ö„Åë„Å¶Ë©±„Åó„Å¶„Åè„Å†„Åï„ÅÑ`;
    }else if(!recognitionSession.resume){
      recStatus.textContent = `${modePrefix}ÂèñÂæó‰∏≠‚Ä¶ Ë©±„ÅóÂßã„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ`;
    }else{
      recStatus.textContent = `${modePrefix}ÂÜçÊé•Á∂ö„Åó„Åæ„Åó„Åü`;
    }
  }

  function handleRecognizerEnd(){
    recognizing = false;
    clearIdleGuard();
    if(userStopRequested || !shouldAutoRestart){
      btnMicStart.disabled = false;
      btnMicStop.disabled = true;
      lastResultKey = '';
      lastSpeedNorm = '';
      pendingGap = false;
      unmatchedCount = 0;
      recStatus.textContent = userStopRequested ? 'ÂÅúÊ≠¢„Åó„Åæ„Åó„Åü' : 'ÂæÖÊ©ü‰∏≠';
      userStopRequested = false;
      shouldAutoRestart = false;
      updateRealtimeTelemetry();
      return;
    }
    clearRestartTimer();
    recStatus.textContent = '‚è≥ ÁÑ°Èü≥„ÅåÁ∂ö„ÅÑ„Åü„Åü„ÇÅÂÜçÊé•Á∂ö„Åó„Å¶„ÅÑ„Åæ„Åô‚Ä¶';
    restartTimer = setTimeout(()=>{ micStart({resume:true, fromRestart:true}); }, 180);
  }

  function handleRecognizerError(ev){
    console.error(ev);
    recStatus.textContent = '„Ç®„É©„Éº: ' + ev.error;
    if(ev.error === 'not-allowed' || ev.error === 'service-not-allowed'){
      shouldAutoRestart = false;
      btnMicStart.disabled = false;
      btnMicStop.disabled = true;
    }
  }

  function handleRecognizerResult(ev){
    lastTranscriptTimestamp = Date.now();
    scheduleIdleGuard();
    let transcript = '';
    let hasFinal = false;
    for(let i=ev.resultIndex; i<ev.results.length; i++){
      transcript += ev.results[i][0].transcript;
      if(ev.results[i].isFinal) hasFinal = true;
    }
    const norm = normalizeForMatch(transcript);
    if(!norm){
      recStatus.textContent = 'ËÅû„ÅçÂèñ„Çä‰∏≠: ' + transcript;
      return;
    }
    const parts = norm.split(' ').filter(Boolean);
    if(parts.length === 0){
      recStatus.textContent = 'ËÅû„ÅçÂèñ„Çä‰∏≠: ' + transcript;
      return;
    }

    if(recognitionMode === 'speed'){
      if(norm === lastSpeedNorm && !hasFinal){
        recStatus.textContent = 'ËÅû„ÅçÂèñ„Çä‰∏≠: ' + transcript;
        return;
      }
      lastSpeedNorm = norm;
      if(normalizedWords.length === 0){
        recStatus.textContent = 'È´òÈÄü„É¢„Éº„Éâ: „ÉÜ„Ç≠„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì';
        return;
      }
      processSpeedRecognition(parts, hasFinal);
      recStatus.textContent = (hasFinal ? 'È´òÈÄüË™çË≠ò: ' : 'È´òÈÄüÂá¶ÁêÜ‰∏≠: ') + transcript;
      return;
    }

    if(norm === lastResultKey && !hasFinal){
      recStatus.textContent = 'ËÅû„ÅçÂèñ„Çä‰∏≠: ' + transcript;
      return;
    }
    lastResultKey = norm;

    let baseIndex = Math.max(currentWord, lastMicIndex);
    if(baseIndex < -1) baseIndex = -1;
    const lookAhead = hasFinal ? 22 : 14;
    const targetIndex = findNextWordIndex(parts, baseIndex, lookAhead);
    if(targetIndex !== -1 && (targetIndex >= currentWord || hasFinal || currentWord === -1)){
      highlightTo(targetIndex, { outcome: 'match' });
    }else{
      unmatchedCount++;
      const needsRecovery = hasFinal || unmatchedCount >= 2 || pendingGap;
      if(needsRecovery){
        const globalIndex = findBestGlobalMatch(parts, Math.max(currentWord, lastMicIndex));
        if(globalIndex !== -1 && (globalIndex >= currentWord || currentWord === -1)){
          highlightTo(globalIndex, { outcome: 'match' });
        }else if(hasFinal && normalizedWords.length){
          const softAdvance = Math.min((currentWord === -1 ? 0 : currentWord + 1), normalizedWords.length - 1);
          if(softAdvance > currentWord){
            highlightTo(softAdvance, { outcome: 'skip', markSkipped:false });
          }else{
            pendingGap = true;
          }
        }else{
          pendingGap = true;
        }
      }else{
        pendingGap = true;
      }
    }

    recStatus.textContent = (hasFinal ? 'Ë™çË≠ò: ' : 'ËÅû„ÅçÂèñ„Çä‰∏≠: ') + transcript;
  }
  function micStop(){
    userStopRequested = true;
    shouldAutoRestart = false;
    clearRestartTimer();
    clearIdleGuard();
    if(recognizer){
      try{ recognizer.stop(); }catch(e){ console.warn(e); }
    }
    lastResultKey = '';
    lastSpeedNorm = '';
    pendingGap = false;
    unmatchedCount = 0;
    resetSpeedState();
    updateRealtimeTelemetry();
  }

  // ====== UI ËøΩÂä†: „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà ======

  document.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase() === 's'){ e.preventDefault(); recognizing ? micStop() : micStart(); }
    
    // Word navigation
    if(e.key === 'ArrowRight' && !e.shiftKey){
      e.preventDefault();
      highlightTo(Math.min(currentWord+1, reader.querySelectorAll('.word').length-1), { manual:true });
    }
    if(e.key === 'ArrowLeft' && !e.shiftKey){
      e.preventDefault();
      highlightTo(Math.max(currentWord-1, 0), { manual:true });
    }
    
    // Language navigation with Shift+Arrow
    if(e.shiftKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')){
      e.preventDefault();
      const currentIndex = recLangRadios.findIndex(r => r.checked);
      if(e.key === 'ArrowLeft' && currentIndex > 0){
        recLangRadios[currentIndex - 1].checked = true;
        recLangRadios[currentIndex - 1].dispatchEvent(new Event('change', {bubbles: true}));
      } else if(e.key === 'ArrowRight' && currentIndex < recLangRadios.length - 1){
        recLangRadios[currentIndex + 1].checked = true;
        recLangRadios[currentIndex + 1].dispatchEvent(new Event('change', {bubbles: true}));
      }
    }
  });

  // ====== „Åù„ÅÆ„Åª„Åã ======
  btnMicStart.addEventListener('click', micStart);
  btnMicStop.addEventListener('click', micStop);
  resetHL.addEventListener('click', ()=>{
    const spans = getWordSpans();
    spans.forEach(span=>{
      span.classList.remove('word--active', 'active');
      applySpanState(span, 'pending');
    });
    resetAllWordStates();
    currentWord = -1;
    lastMicIndex = -1;
    lastResultKey = '';
    lastSpeedNorm = '';
    unmatchedCount = 0;
    pendingGap = false;
    resetSpeedState();
  });
  recModeRadios.forEach(radio=>{
    radio.addEventListener('change', ()=>{
      if(!radio.checked) return;
      recognitionMode = radio.value;
      lastResultKey = '';
      lastSpeedNorm = '';
      unmatchedCount = 0;
      pendingGap = false;
      resetSpeedState();
      speedState.lastReliable = currentWord;
      speedState.anchor = currentWord;
      recStatus.textContent = recognitionMode === 'speed' ? 'È´òÈÄü„É¢„Éº„ÉâÊ∫ñÂÇôÂÆå‰∫Ü' : 'Ê≠£Á¢∫„É¢„Éº„ÉâÊ∫ñÂÇôÂÆå‰∫Ü';
    });
  });

  loadSample.addEventListener('click', ()=>{
    const sample = `Teacher: Today's unit question is "How do we make decisions?"\nYuna: We make decisions every day‚Äîwhat to wear, what to eat, what to watch.\nTeacher: Great. What kinds of factors affect our decisions?\nSophy: A big factor for me is my parents' opinions.\nTeacher: Often other people influence our choices. What else?\nMarcus: Sometimes we want to change or feel better about ourselves.`;
    textInput.value = sample; tokenize(sample); render();
  });

  // ====== Theme Toggle ======
  const themeToggle = document.getElementById('themeToggle');
  const themeIcon = document.getElementById('themeIcon');
  const themeText = document.getElementById('themeText');
  
  function setTheme(theme) {
    if (theme === 'dark') {
      document.documentElement.setAttribute('data-theme', 'dark');
      themeIcon.textContent = '‚òÄÔ∏è';
      themeText.textContent = '„É©„Ç§„Éà„É¢„Éº„Éâ';
      localStorage.setItem('theme', 'dark');
    } else {
      document.documentElement.removeAttribute('data-theme');
      themeIcon.textContent = 'üåô';
      themeText.textContent = '„ÉÄ„Éº„ÇØ„É¢„Éº„Éâ';
      localStorage.setItem('theme', 'light');
    }
  }
  
  // Load saved theme or detect system preference
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme) {
    setTheme(savedTheme);
  } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    setTheme('dark');
  }
  
  themeToggle.addEventListener('click', () => {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    setTheme(currentTheme === 'dark' ? 'light' : 'dark');
  });

  // ÂàùÊúüÊèèÁîª
  tokenize(''); render();
  reader.style.fontSize = '16px';
  reader.style.lineHeight = '1.7';
  recStatus.textContent = 'Ê∫ñÂÇôÂÆå‰∫Ü';
  </script>
</body>
</html>
